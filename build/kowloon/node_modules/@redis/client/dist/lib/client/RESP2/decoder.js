"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var errors_1 = require("../../errors");
var buffer_1 = require("./composers/buffer");
var string_1 = require("./composers/string");
// RESP2 specification
// https://redis.io/topics/protocol
var Types;
(function (Types) {
  Types[Types["SIMPLE_STRING"] = 43] = "SIMPLE_STRING";
  Types[Types["ERROR"] = 45] = "ERROR";
  Types[Types["INTEGER"] = 58] = "INTEGER";
  Types[Types["BULK_STRING"] = 36] = "BULK_STRING";
  Types[Types["ARRAY"] = 42] = "ARRAY"; // *
})(Types || (Types = {}));
var ASCII;
(function (ASCII) {
  ASCII[ASCII["CR"] = 13] = "CR";
  ASCII[ASCII["ZERO"] = 48] = "ZERO";
  ASCII[ASCII["MINUS"] = 45] = "MINUS";
})(ASCII || (ASCII = {}));
// Using TypeScript `private` and not the build-in `#` to avoid __classPrivateFieldGet and __classPrivateFieldSet
var RESP2Decoder = /*#__PURE__*/function () {
  function RESP2Decoder(options) {
    _classCallCheck(this, RESP2Decoder);
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: options
    });
    Object.defineProperty(this, "cursor", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "bufferComposer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new buffer_1["default"]()
    });
    Object.defineProperty(this, "stringComposer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new string_1["default"]()
    });
    Object.defineProperty(this, "currentStringComposer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.stringComposer
    });
    Object.defineProperty(this, "integer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "isNegativeInteger", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "bulkStringRemainingLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "arraysInProcess", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "initializeArray", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "arrayItemType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  _createClass(RESP2Decoder, [{
    key: "reset",
    value: function reset() {
      this.cursor = 0;
      this.type = undefined;
      this.bufferComposer.reset();
      this.stringComposer.reset();
      this.currentStringComposer = this.stringComposer;
    }
  }, {
    key: "write",
    value: function write(chunk) {
      while (this.cursor < chunk.length) {
        if (!this.type) {
          this.currentStringComposer = this.options.returnStringsAsBuffers() ? this.bufferComposer : this.stringComposer;
          this.type = chunk[this.cursor];
          if (++this.cursor >= chunk.length) break;
        }
        var reply = this.parseType(chunk, this.type);
        if (reply === undefined) break;
        this.type = undefined;
        this.options.onReply(reply);
      }
      this.cursor -= chunk.length;
    }
  }, {
    key: "parseType",
    value: function parseType(chunk, type, arraysToKeep) {
      switch (type) {
        case Types.SIMPLE_STRING:
          return this.parseSimpleString(chunk);
        case Types.ERROR:
          return this.parseError(chunk);
        case Types.INTEGER:
          return this.parseInteger(chunk);
        case Types.BULK_STRING:
          return this.parseBulkString(chunk);
        case Types.ARRAY:
          return this.parseArray(chunk, arraysToKeep);
      }
    }
  }, {
    key: "compose",
    value: function compose(chunk, composer) {
      for (var i = this.cursor; i < chunk.length; i++) {
        if (chunk[i] === ASCII.CR) {
          var reply = composer.end(chunk.subarray(this.cursor, i));
          this.cursor = i + 2;
          return reply;
        }
      }
      var toWrite = chunk.subarray(this.cursor);
      composer.write(toWrite);
      this.cursor = chunk.length;
    }
  }, {
    key: "parseSimpleString",
    value: function parseSimpleString(chunk) {
      return this.compose(chunk, this.currentStringComposer);
    }
  }, {
    key: "parseError",
    value: function parseError(chunk) {
      var message = this.compose(chunk, this.stringComposer);
      if (message !== undefined) {
        return new errors_1.ErrorReply(message);
      }
    }
  }, {
    key: "parseInteger",
    value: function parseInteger(chunk) {
      if (this.isNegativeInteger === undefined) {
        this.isNegativeInteger = chunk[this.cursor] === ASCII.MINUS;
        if (this.isNegativeInteger && ++this.cursor === chunk.length) return;
      }
      do {
        var _byte = chunk[this.cursor];
        if (_byte === ASCII.CR) {
          var integer = this.isNegativeInteger ? -this.integer : this.integer;
          this.integer = 0;
          this.isNegativeInteger = undefined;
          this.cursor += 2;
          return integer;
        }
        this.integer = this.integer * 10 + _byte - ASCII.ZERO;
      } while (++this.cursor < chunk.length);
    }
  }, {
    key: "parseBulkString",
    value: function parseBulkString(chunk) {
      if (this.bulkStringRemainingLength === undefined) {
        var length = this.parseInteger(chunk);
        if (length === undefined) return;
        if (length === -1) return null;
        this.bulkStringRemainingLength = length;
        if (this.cursor >= chunk.length) return;
      }
      var end = this.cursor + this.bulkStringRemainingLength;
      if (chunk.length >= end) {
        var reply = this.currentStringComposer.end(chunk.subarray(this.cursor, end));
        this.bulkStringRemainingLength = undefined;
        this.cursor = end + 2;
        return reply;
      }
      var toWrite = chunk.subarray(this.cursor);
      this.currentStringComposer.write(toWrite);
      this.bulkStringRemainingLength -= toWrite.length;
      this.cursor = chunk.length;
    }
  }, {
    key: "parseArray",
    value: function parseArray(chunk) {
      var arraysToKeep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (this.initializeArray || this.arraysInProcess.length === arraysToKeep) {
        var length = this.parseInteger(chunk);
        if (length === undefined) {
          this.initializeArray = true;
          return undefined;
        }
        this.initializeArray = false;
        this.arrayItemType = undefined;
        if (length === -1) {
          return this.returnArrayReply(null, arraysToKeep, chunk);
        } else if (length === 0) {
          return this.returnArrayReply([], arraysToKeep, chunk);
        }
        this.arraysInProcess.push({
          array: new Array(length),
          pushCounter: 0
        });
      }
      while (this.cursor < chunk.length) {
        if (!this.arrayItemType) {
          this.arrayItemType = chunk[this.cursor];
          if (++this.cursor >= chunk.length) break;
        }
        var item = this.parseType(chunk, this.arrayItemType, arraysToKeep + 1);
        if (item === undefined) break;
        this.arrayItemType = undefined;
        var reply = this.pushArrayItem(item, arraysToKeep);
        if (reply !== undefined) return reply;
      }
    }
  }, {
    key: "returnArrayReply",
    value: function returnArrayReply(reply, arraysToKeep, chunk) {
      if (this.arraysInProcess.length <= arraysToKeep) return reply;
      return this.pushArrayItem(reply, arraysToKeep, chunk);
    }
  }, {
    key: "pushArrayItem",
    value: function pushArrayItem(item, arraysToKeep, chunk) {
      var to = this.arraysInProcess[this.arraysInProcess.length - 1];
      to.array[to.pushCounter] = item;
      if (++to.pushCounter === to.array.length) {
        return this.returnArrayReply(this.arraysInProcess.pop().array, arraysToKeep, chunk);
      } else if (chunk && chunk.length > this.cursor) {
        return this.parseArray(chunk, arraysToKeep);
      }
    }
  }]);
  return RESP2Decoder;
}();
exports["default"] = RESP2Decoder;