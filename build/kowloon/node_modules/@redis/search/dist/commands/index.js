"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformProfile = exports.pushSearchOptions = exports.pushParamsArgs = exports.pushSchema = exports.VectorAlgorithms = exports.SchemaTextFieldPhonetics = exports.SchemaFieldTypes = exports.pushArgumentsWithLength = exports.pushSortByArguments = exports.pushSortByProperty = exports.RedisSearchLanguages = void 0;
var _LIST = require("./_LIST");
var ALTER = require("./ALTER");
var AGGREGATE_WITHCURSOR = require("./AGGREGATE_WITHCURSOR");
var AGGREGATE = require("./AGGREGATE");
var ALIASADD = require("./ALIASADD");
var ALIASDEL = require("./ALIASDEL");
var ALIASUPDATE = require("./ALIASUPDATE");
var CONFIG_GET = require("./CONFIG_GET");
var CONFIG_SET = require("./CONFIG_SET");
var CREATE = require("./CREATE");
var CURSOR_DEL = require("./CURSOR_DEL");
var CURSOR_READ = require("./CURSOR_READ");
var DICTADD = require("./DICTADD");
var DICTDEL = require("./DICTDEL");
var DICTDUMP = require("./DICTDUMP");
var DROPINDEX = require("./DROPINDEX");
var EXPLAIN = require("./EXPLAIN");
var EXPLAINCLI = require("./EXPLAINCLI");
var INFO = require("./INFO");
var PROFILESEARCH = require("./PROFILE_SEARCH");
var PROFILEAGGREGATE = require("./PROFILE_AGGREGATE");
var SEARCH = require("./SEARCH");
var SPELLCHECK = require("./SPELLCHECK");
var SUGADD = require("./SUGADD");
var SUGDEL = require("./SUGDEL");
var SUGGET_WITHPAYLOADS = require("./SUGGET_WITHPAYLOADS");
var SUGGET_WITHSCORES_WITHPAYLOADS = require("./SUGGET_WITHSCORES_WITHPAYLOADS");
var SUGGET_WITHSCORES = require("./SUGGET_WITHSCORES");
var SUGGET = require("./SUGGET");
var SUGLEN = require("./SUGLEN");
var SYNDUMP = require("./SYNDUMP");
var SYNUPDATE = require("./SYNUPDATE");
var TAGVALS = require("./TAGVALS");
var generic_transformers_1 = require("@redis/client/dist/lib/commands/generic-transformers");
exports["default"] = {
  _LIST: _LIST,
  _list: _LIST,
  ALTER: ALTER,
  alter: ALTER,
  AGGREGATE_WITHCURSOR: AGGREGATE_WITHCURSOR,
  aggregateWithCursor: AGGREGATE_WITHCURSOR,
  AGGREGATE: AGGREGATE,
  aggregate: AGGREGATE,
  ALIASADD: ALIASADD,
  aliasAdd: ALIASADD,
  ALIASDEL: ALIASDEL,
  aliasDel: ALIASDEL,
  ALIASUPDATE: ALIASUPDATE,
  aliasUpdate: ALIASUPDATE,
  CONFIG_GET: CONFIG_GET,
  configGet: CONFIG_GET,
  CONFIG_SET: CONFIG_SET,
  configSet: CONFIG_SET,
  CREATE: CREATE,
  create: CREATE,
  CURSOR_DEL: CURSOR_DEL,
  cursorDel: CURSOR_DEL,
  CURSOR_READ: CURSOR_READ,
  cursorRead: CURSOR_READ,
  DICTADD: DICTADD,
  dictAdd: DICTADD,
  DICTDEL: DICTDEL,
  dictDel: DICTDEL,
  DICTDUMP: DICTDUMP,
  dictDump: DICTDUMP,
  DROPINDEX: DROPINDEX,
  dropIndex: DROPINDEX,
  EXPLAIN: EXPLAIN,
  explain: EXPLAIN,
  EXPLAINCLI: EXPLAINCLI,
  explainCli: EXPLAINCLI,
  INFO: INFO,
  info: INFO,
  PROFILESEARCH: PROFILESEARCH,
  profileSearch: PROFILESEARCH,
  PROFILEAGGREGATE: PROFILEAGGREGATE,
  profileAggregate: PROFILEAGGREGATE,
  SEARCH: SEARCH,
  search: SEARCH,
  SPELLCHECK: SPELLCHECK,
  spellCheck: SPELLCHECK,
  SUGADD: SUGADD,
  sugAdd: SUGADD,
  SUGDEL: SUGDEL,
  sugDel: SUGDEL,
  SUGGET_WITHPAYLOADS: SUGGET_WITHPAYLOADS,
  sugGetWithPayloads: SUGGET_WITHPAYLOADS,
  SUGGET_WITHSCORES_WITHPAYLOADS: SUGGET_WITHSCORES_WITHPAYLOADS,
  sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS,
  SUGGET_WITHSCORES: SUGGET_WITHSCORES,
  sugGetWithScores: SUGGET_WITHSCORES,
  SUGGET: SUGGET,
  sugGet: SUGGET,
  SUGLEN: SUGLEN,
  sugLen: SUGLEN,
  SYNDUMP: SYNDUMP,
  synDump: SYNDUMP,
  SYNUPDATE: SYNUPDATE,
  synUpdate: SYNUPDATE,
  TAGVALS: TAGVALS,
  tagVals: TAGVALS
};
var RedisSearchLanguages;
(function (RedisSearchLanguages) {
  RedisSearchLanguages["ARABIC"] = "Arabic";
  RedisSearchLanguages["BASQUE"] = "Basque";
  RedisSearchLanguages["CATALANA"] = "Catalan";
  RedisSearchLanguages["DANISH"] = "Danish";
  RedisSearchLanguages["DUTCH"] = "Dutch";
  RedisSearchLanguages["ENGLISH"] = "English";
  RedisSearchLanguages["FINNISH"] = "Finnish";
  RedisSearchLanguages["FRENCH"] = "French";
  RedisSearchLanguages["GERMAN"] = "German";
  RedisSearchLanguages["GREEK"] = "Greek";
  RedisSearchLanguages["HUNGARIAN"] = "Hungarian";
  RedisSearchLanguages["INDONESAIN"] = "Indonesian";
  RedisSearchLanguages["IRISH"] = "Irish";
  RedisSearchLanguages["ITALIAN"] = "Italian";
  RedisSearchLanguages["LITHUANIAN"] = "Lithuanian";
  RedisSearchLanguages["NEPALI"] = "Nepali";
  RedisSearchLanguages["NORWEIGAN"] = "Norwegian";
  RedisSearchLanguages["PORTUGUESE"] = "Portuguese";
  RedisSearchLanguages["ROMANIAN"] = "Romanian";
  RedisSearchLanguages["RUSSIAN"] = "Russian";
  RedisSearchLanguages["SPANISH"] = "Spanish";
  RedisSearchLanguages["SWEDISH"] = "Swedish";
  RedisSearchLanguages["TAMIL"] = "Tamil";
  RedisSearchLanguages["TURKISH"] = "Turkish";
  RedisSearchLanguages["CHINESE"] = "Chinese";
})(RedisSearchLanguages = exports.RedisSearchLanguages || (exports.RedisSearchLanguages = {}));
function pushSortByProperty(args, sortBy) {
  if (typeof sortBy === 'string') {
    args.push(sortBy);
  } else {
    args.push(sortBy.BY);
    if (sortBy.DIRECTION) {
      args.push(sortBy.DIRECTION);
    }
  }
}
exports.pushSortByProperty = pushSortByProperty;
function pushSortByArguments(args, name, sortBy) {
  var lengthBefore = args.push(name, '' // will be overwritten
  );

  if (Array.isArray(sortBy)) {
    var _iterator = _createForOfIteratorHelper(sortBy),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var field = _step.value;
        pushSortByProperty(args, field);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    pushSortByProperty(args, sortBy);
  }
  args[lengthBefore - 1] = (args.length - lengthBefore).toString();
  return args;
}
exports.pushSortByArguments = pushSortByArguments;
function pushArgumentsWithLength(args, fn) {
  var lengthIndex = args.push('') - 1;
  fn(args);
  args[lengthIndex] = (args.length - lengthIndex - 1).toString();
  return args;
}
exports.pushArgumentsWithLength = pushArgumentsWithLength;
var SchemaFieldTypes;
(function (SchemaFieldTypes) {
  SchemaFieldTypes["TEXT"] = "TEXT";
  SchemaFieldTypes["NUMERIC"] = "NUMERIC";
  SchemaFieldTypes["GEO"] = "GEO";
  SchemaFieldTypes["TAG"] = "TAG";
  SchemaFieldTypes["VECTOR"] = "VECTOR";
})(SchemaFieldTypes = exports.SchemaFieldTypes || (exports.SchemaFieldTypes = {}));
var SchemaTextFieldPhonetics;
(function (SchemaTextFieldPhonetics) {
  SchemaTextFieldPhonetics["DM_EN"] = "dm:en";
  SchemaTextFieldPhonetics["DM_FR"] = "dm:fr";
  SchemaTextFieldPhonetics["FM_PT"] = "dm:pt";
  SchemaTextFieldPhonetics["DM_ES"] = "dm:es";
})(SchemaTextFieldPhonetics = exports.SchemaTextFieldPhonetics || (exports.SchemaTextFieldPhonetics = {}));
var VectorAlgorithms;
(function (VectorAlgorithms) {
  VectorAlgorithms["FLAT"] = "FLAT";
  VectorAlgorithms["HNSW"] = "HNSW";
})(VectorAlgorithms = exports.VectorAlgorithms || (exports.VectorAlgorithms = {}));
function pushSchema(args, schema) {
  var _loop = function _loop() {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      field = _Object$entries$_i[0],
      fieldOptions = _Object$entries$_i[1];
    args.push(field);
    if (typeof fieldOptions === 'string') {
      args.push(fieldOptions);
      return "continue";
    }
    if (fieldOptions.AS) {
      args.push('AS', fieldOptions.AS);
    }
    args.push(fieldOptions.type);
    switch (fieldOptions.type) {
      case SchemaFieldTypes.TEXT:
        if (fieldOptions.NOSTEM) {
          args.push('NOSTEM');
        }
        if (fieldOptions.WEIGHT) {
          args.push('WEIGHT', fieldOptions.WEIGHT.toString());
        }
        if (fieldOptions.PHONETIC) {
          args.push('PHONETIC', fieldOptions.PHONETIC);
        }
        if (fieldOptions.WITHSUFFIXTRIE) {
          args.push('WITHSUFFIXTRIE');
        }
        break;
      // case SchemaFieldTypes.NUMERIC:
      // case SchemaFieldTypes.GEO:
      //     break;
      case SchemaFieldTypes.TAG:
        if (fieldOptions.SEPARATOR) {
          args.push('SEPARATOR', fieldOptions.SEPARATOR);
        }
        if (fieldOptions.CASESENSITIVE) {
          args.push('CASESENSITIVE');
        }
        if (fieldOptions.WITHSUFFIXTRIE) {
          args.push('WITHSUFFIXTRIE');
        }
        break;
      case SchemaFieldTypes.VECTOR:
        args.push(fieldOptions.ALGORITHM);
        pushArgumentsWithLength(args, function () {
          args.push('TYPE', fieldOptions.TYPE, 'DIM', fieldOptions.DIM.toString(), 'DISTANCE_METRIC', fieldOptions.DISTANCE_METRIC);
          if (fieldOptions.INITIAL_CAP) {
            args.push('INITIAL_CAP', fieldOptions.INITIAL_CAP.toString());
          }
          switch (fieldOptions.ALGORITHM) {
            case VectorAlgorithms.FLAT:
              if (fieldOptions.BLOCK_SIZE) {
                args.push('BLOCK_SIZE', fieldOptions.BLOCK_SIZE.toString());
              }
              break;
            case VectorAlgorithms.HNSW:
              if (fieldOptions.M) {
                args.push('M', fieldOptions.M.toString());
              }
              if (fieldOptions.EF_CONSTRUCTION) {
                args.push('EF_CONSTRUCTION', fieldOptions.EF_CONSTRUCTION.toString());
              }
              if (fieldOptions.EF_RUNTIME) {
                args.push('EF_RUNTIME', fieldOptions.EF_RUNTIME.toString());
              }
              break;
          }
        });
        return "continue";
      // vector fields do not contain SORTABLE and NOINDEX options
    }

    if (fieldOptions.SORTABLE) {
      args.push('SORTABLE');
      if (fieldOptions.SORTABLE === 'UNF') {
        args.push('UNF');
      }
    }
    if (fieldOptions.NOINDEX) {
      args.push('NOINDEX');
    }
  };
  for (var _i = 0, _Object$entries = Object.entries(schema); _i < _Object$entries.length; _i++) {
    var _ret = _loop();
    if (_ret === "continue") continue;
  }
}
exports.pushSchema = pushSchema;
function pushParamsArgs(args, params) {
  if (params) {
    var enrties = Object.entries(params);
    args.push('PARAMS', (enrties.length * 2).toString());
    for (var _i2 = 0, _enrties = enrties; _i2 < _enrties.length; _i2++) {
      var _enrties$_i = _slicedToArray(_enrties[_i2], 2),
        key = _enrties$_i[0],
        value = _enrties$_i[1];
      args.push(key, typeof value === 'number' ? value.toString() : value);
    }
  }
  return args;
}
exports.pushParamsArgs = pushParamsArgs;
function pushSearchOptions(args, options) {
  var _options$RETURN;
  if (options !== null && options !== void 0 && options.VERBATIM) {
    args.push('VERBATIM');
  }
  if (options !== null && options !== void 0 && options.NOSTOPWORDS) {
    args.push('NOSTOPWORDS');
  }
  // if (options?.WITHSCORES) {
  //     args.push('WITHSCORES');
  // }
  // if (options?.WITHPAYLOADS) {
  //     args.push('WITHPAYLOADS');
  // }
  (0, generic_transformers_1.pushOptionalVerdictArgument)(args, 'INKEYS', options === null || options === void 0 ? void 0 : options.INKEYS);
  (0, generic_transformers_1.pushOptionalVerdictArgument)(args, 'INFIELDS', options === null || options === void 0 ? void 0 : options.INFIELDS);
  (0, generic_transformers_1.pushOptionalVerdictArgument)(args, 'RETURN', options === null || options === void 0 ? void 0 : options.RETURN);
  if (options !== null && options !== void 0 && options.SUMMARIZE) {
    args.push('SUMMARIZE');
    if (_typeof(options.SUMMARIZE) === 'object') {
      if (options.SUMMARIZE.FIELDS) {
        args.push('FIELDS');
        (0, generic_transformers_1.pushVerdictArgument)(args, options.SUMMARIZE.FIELDS);
      }
      if (options.SUMMARIZE.FRAGS) {
        args.push('FRAGS', options.SUMMARIZE.FRAGS.toString());
      }
      if (options.SUMMARIZE.LEN) {
        args.push('LEN', options.SUMMARIZE.LEN.toString());
      }
      if (options.SUMMARIZE.SEPARATOR) {
        args.push('SEPARATOR', options.SUMMARIZE.SEPARATOR);
      }
    }
  }
  if (options !== null && options !== void 0 && options.HIGHLIGHT) {
    args.push('HIGHLIGHT');
    if (_typeof(options.HIGHLIGHT) === 'object') {
      if (options.HIGHLIGHT.FIELDS) {
        args.push('FIELDS');
        (0, generic_transformers_1.pushVerdictArgument)(args, options.HIGHLIGHT.FIELDS);
      }
      if (options.HIGHLIGHT.TAGS) {
        args.push('TAGS', options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
      }
    }
  }
  if (options !== null && options !== void 0 && options.SLOP) {
    args.push('SLOP', options.SLOP.toString());
  }
  if (options !== null && options !== void 0 && options.INORDER) {
    args.push('INORDER');
  }
  if (options !== null && options !== void 0 && options.LANGUAGE) {
    args.push('LANGUAGE', options.LANGUAGE);
  }
  if (options !== null && options !== void 0 && options.EXPANDER) {
    args.push('EXPANDER', options.EXPANDER);
  }
  if (options !== null && options !== void 0 && options.SCORER) {
    args.push('SCORER', options.SCORER);
  }
  // if (options?.EXPLAINSCORE) {
  //     args.push('EXPLAINSCORE');
  // }
  // if (options?.PAYLOAD) {
  //     args.push('PAYLOAD', options.PAYLOAD);
  // }
  if (options !== null && options !== void 0 && options.SORTBY) {
    args.push('SORTBY');
    pushSortByProperty(args, options.SORTBY);
  }
  // if (options?.MSORTBY) {
  //     pushSortByArguments(args, 'MSORTBY', options.MSORTBY);
  // }
  if (options !== null && options !== void 0 && options.LIMIT) {
    args.push('LIMIT', options.LIMIT.from.toString(), options.LIMIT.size.toString());
  }
  if (options !== null && options !== void 0 && options.PARAMS) {
    pushParamsArgs(args, options.PARAMS);
  }
  if (options !== null && options !== void 0 && options.DIALECT) {
    args.push('DIALECT', options.DIALECT.toString());
  }
  if ((options === null || options === void 0 ? void 0 : (_options$RETURN = options.RETURN) === null || _options$RETURN === void 0 ? void 0 : _options$RETURN.length) === 0) {
    args.preserve = true;
  }
  if ((options === null || options === void 0 ? void 0 : options.TIMEOUT) !== undefined) {
    args.push('TIMEOUT', options.TIMEOUT.toString());
  }
  return args;
}
exports.pushSearchOptions = pushSearchOptions;
function transformProfile(reply) {
  return {
    totalProfileTime: reply[0][1],
    parsingTime: reply[1][1],
    pipelineCreationTime: reply[2][1],
    iteratorsProfile: transformIterators(reply[3][1])
  };
}
exports.transformProfile = transformProfile;
function transformIterators(IteratorsProfile) {
  var res = {};
  for (var i = 0; i < IteratorsProfile.length; i += 2) {
    var value = IteratorsProfile[i + 1];
    switch (IteratorsProfile[i]) {
      case 'Type':
        res.type = value;
        break;
      case 'Counter':
        res.counter = value;
        break;
      case 'Time':
        res.time = value;
        break;
      case 'Query type':
        res.queryType = value;
        break;
      case 'Child iterators':
        res.childIterators = value.map(transformChildIterators);
        break;
    }
  }
  return res;
}
function transformChildIterators(IteratorsProfile) {
  var res = {};
  for (var i = 1; i < IteratorsProfile.length; i += 2) {
    var value = IteratorsProfile[i + 1];
    switch (IteratorsProfile[i]) {
      case 'Type':
        res.type = value;
        break;
      case 'Counter':
        res.counter = value;
        break;
      case 'Time':
        res.time = value;
        break;
      case 'Size':
        res.size = value;
        break;
      case 'Term':
        res.term = value;
        break;
      case 'Child iterators':
        res.childIterators = value.map(transformChildIterators);
        break;
    }
  }
  return res;
}