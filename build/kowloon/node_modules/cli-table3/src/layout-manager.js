"use strict";

var _require = require('./debug'),
  warn = _require.warn,
  debug = _require.debug;
var Cell = require('./cell');
var ColSpanCell = Cell.ColSpanCell,
  RowSpanCell = Cell.RowSpanCell;
(function () {
  function next(alloc, col) {
    if (alloc[col] > 0) {
      return next(alloc, col + 1);
    }
    return col;
  }
  function layoutTable(table) {
    var alloc = {};
    table.forEach(function (row, rowIndex) {
      var col = 0;
      row.forEach(function (cell) {
        cell.y = rowIndex;
        // Avoid erroneous call to next() on first row
        cell.x = rowIndex ? next(alloc, col) : col;
        var rowSpan = cell.rowSpan || 1;
        var colSpan = cell.colSpan || 1;
        if (rowSpan > 1) {
          for (var cs = 0; cs < colSpan; cs++) {
            alloc[cell.x + cs] = rowSpan;
          }
        }
        col = cell.x + colSpan;
      });
      Object.keys(alloc).forEach(function (idx) {
        alloc[idx]--;
        if (alloc[idx] < 1) delete alloc[idx];
      });
    });
  }
  function maxWidth(table) {
    var mw = 0;
    table.forEach(function (row) {
      row.forEach(function (cell) {
        mw = Math.max(mw, cell.x + (cell.colSpan || 1));
      });
    });
    return mw;
  }
  function maxHeight(table) {
    return table.length;
  }
  function cellsConflict(cell1, cell2) {
    var yMin1 = cell1.y;
    var yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);
    var yMin2 = cell2.y;
    var yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);
    var yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);
    var xMin1 = cell1.x;
    var xMax1 = cell1.x - 1 + (cell1.colSpan || 1);
    var xMin2 = cell2.x;
    var xMax2 = cell2.x - 1 + (cell2.colSpan || 1);
    var xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);
    return yConflict && xConflict;
  }
  function conflictExists(rows, x, y) {
    var i_max = Math.min(rows.length - 1, y);
    var cell = {
      x: x,
      y: y
    };
    for (var i = 0; i <= i_max; i++) {
      var row = rows[i];
      for (var j = 0; j < row.length; j++) {
        if (cellsConflict(cell, row[j])) {
          return true;
        }
      }
    }
    return false;
  }
  function allBlank(rows, y, xMin, xMax) {
    for (var x = xMin; x < xMax; x++) {
      if (conflictExists(rows, x, y)) {
        return false;
      }
    }
    return true;
  }
  function addRowSpanCells(table) {
    table.forEach(function (row, rowIndex) {
      row.forEach(function (cell) {
        for (var i = 1; i < cell.rowSpan; i++) {
          var rowSpanCell = new RowSpanCell(cell);
          rowSpanCell.x = cell.x;
          rowSpanCell.y = cell.y + i;
          rowSpanCell.colSpan = cell.colSpan;
          insertCell(rowSpanCell, table[rowIndex + i]);
        }
      });
    });
  }
  function addColSpanCells(cellRows) {
    for (var rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {
      var cellColumns = cellRows[rowIndex];
      for (var columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {
        var cell = cellColumns[columnIndex];
        for (var k = 1; k < cell.colSpan; k++) {
          var colSpanCell = new ColSpanCell();
          colSpanCell.x = cell.x + k;
          colSpanCell.y = cell.y;
          cellColumns.splice(columnIndex + 1, 0, colSpanCell);
        }
      }
    }
  }
  function insertCell(cell, row) {
    var x = 0;
    while (x < row.length && row[x].x < cell.x) {
      x++;
    }
    row.splice(x, 0, cell);
  }
  function fillInTable(table) {
    var h_max = maxHeight(table);
    var w_max = maxWidth(table);
    debug("Max rows: ".concat(h_max, "; Max cols: ").concat(w_max));
    for (var y = 0; y < h_max; y++) {
      for (var x = 0; x < w_max; x++) {
        if (!conflictExists(table, x, y)) {
          var opts = {
            x: x,
            y: y,
            colSpan: 1,
            rowSpan: 1
          };
          x++;
          while (x < w_max && !conflictExists(table, x, y)) {
            opts.colSpan++;
            x++;
          }
          var y2 = y + 1;
          while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {
            opts.rowSpan++;
            y2++;
          }
          var cell = new Cell(opts);
          cell.x = opts.x;
          cell.y = opts.y;
          warn("Missing cell at ".concat(cell.y, "-").concat(cell.x, "."));
          insertCell(cell, table[y]);
        }
      }
    }
  }
  function generateCells(rows) {
    return rows.map(function (row) {
      if (!Array.isArray(row)) {
        var key = Object.keys(row)[0];
        row = row[key];
        if (Array.isArray(row)) {
          row = row.slice();
          row.unshift(key);
        } else {
          row = [key, row];
        }
      }
      return row.map(function (cell) {
        return new Cell(cell);
      });
    });
  }
  function makeTableLayout(rows) {
    var cellRows = generateCells(rows);
    layoutTable(cellRows);
    fillInTable(cellRows);
    addRowSpanCells(cellRows);
    addColSpanCells(cellRows);
    return cellRows;
  }
  module.exports = {
    makeTableLayout: makeTableLayout,
    layoutTable: layoutTable,
    addRowSpanCells: addRowSpanCells,
    maxWidth: maxWidth,
    fillInTable: fillInTable,
    computeWidths: makeComputeWidths('colSpan', 'desiredWidth', 'x', 1),
    computeHeights: makeComputeWidths('rowSpan', 'desiredHeight', 'y', 1)
  };
})();
function makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {
  return function (vals, table) {
    var result = [];
    var spanners = [];
    var auto = {};
    table.forEach(function (row) {
      row.forEach(function (cell) {
        if ((cell[colSpan] || 1) > 1) {
          spanners.push(cell);
        } else {
          result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);
        }
      });
    });
    vals.forEach(function (val, index) {
      if (typeof val === 'number') {
        result[index] = val;
      }
    });

    //spanners.forEach(function(cell){
    for (var k = spanners.length - 1; k >= 0; k--) {
      var cell = spanners[k];
      var span = cell[colSpan];
      var col = cell[x];
      var existingWidth = result[col];
      var editableCols = typeof vals[col] === 'number' ? 0 : 1;
      if (typeof existingWidth === 'number') {
        for (var i = 1; i < span; i++) {
          existingWidth += 1 + result[col + i];
          if (typeof vals[col + i] !== 'number') {
            editableCols++;
          }
        }
      } else {
        existingWidth = desiredWidth === 'desiredWidth' ? cell.desiredWidth - 1 : 1;
        if (!auto[col] || auto[col] < existingWidth) {
          auto[col] = existingWidth;
        }
      }
      if (cell[desiredWidth] > existingWidth) {
        var _i = 0;
        while (editableCols > 0 && cell[desiredWidth] > existingWidth) {
          if (typeof vals[col + _i] !== 'number') {
            var dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
            existingWidth += dif;
            result[col + _i] += dif;
            editableCols--;
          }
          _i++;
        }
      }
    }
    Object.assign(vals, result, auto);
    for (var j = 0; j < vals.length; j++) {
      vals[j] = Math.max(forcedMin, vals[j] || 0);
    }
  };
}