"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var debug = require('debug')('cypress:cli');
var util = require('../util');
var spawn = require('./spawn');
var verify = require('../tasks/verify');
var _require = require('./shared'),
  processTestingType = _require.processTestingType,
  checkConfigFile = _require.checkConfigFile;
var _require2 = require('../errors'),
  exitWithError = _require2.exitWithError;

/**
 * Maps options collected by the CLI
 * and forms list of CLI arguments to the server.
 *
 * Note: there is lightweight validation, with errors
 * thrown synchronously.
 *
 * @returns {string[]} list of CLI arguments
 */
var processOpenOptions = function processOpenOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // In addition to setting the project directory, setting the project option
  // here ultimately decides whether cypress is run in global mode or not.
  // It's first based off whether it's installed globally by npm/yarn (-g).
  // A global install can be overridden by the --project flag, putting Cypress
  // in project mode. A non-global install can be overridden by the --global
  // flag, putting it in global mode.
  if (!util.isInstalledGlobally() && !options.global && !options.project) {
    options.project = process.cwd();
  }
  var args = [];
  if (options.config) {
    args.push('--config', options.config);
  }
  if (options.configFile !== undefined) {
    checkConfigFile(options);
    args.push('--config-file', options.configFile);
  }
  if (options.browser) {
    args.push('--browser', options.browser);
  }
  if (options.env) {
    args.push('--env', options.env);
  }
  if (options.port) {
    args.push('--port', options.port);
  }
  if (options.project) {
    args.push('--project', options.project);
  }
  if (options.global) {
    args.push('--global', options.global);
  }
  if (options.inspect) {
    args.push('--inspect');
  }
  if (options.inspectBrk) {
    args.push('--inspectBrk');
  }
  args.push.apply(args, _toConsumableArray(processTestingType(options)));
  debug('opening from options %j', options);
  debug('command line arguments %j', args);
  return args;
};
module.exports = {
  processOpenOptions: processOpenOptions,
  start: function start() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    function open() {
      try {
        var args = processOpenOptions(options);
        return spawn.start(args, {
          dev: options.dev,
          detached: Boolean(options.detached)
        });
      } catch (err) {
        if (err.details) {
          return exitWithError(err.details)();
        }
        throw err;
      }
    }
    if (options.dev) {
      return open();
    }
    return verify.start().then(open);
  }
};