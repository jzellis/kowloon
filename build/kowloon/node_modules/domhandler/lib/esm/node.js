"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Text = exports.ProcessingInstruction = exports.NodeWithChildren = exports.Node = exports.Element = exports.Document = exports.DataNode = exports.Comment = exports.CDATA = void 0;
exports.cloneNode = _cloneNode;
exports.hasChildren = hasChildren;
exports.isCDATA = isCDATA;
exports.isComment = isComment;
exports.isDirective = isDirective;
exports.isDocument = isDocument;
exports.isTag = isTag;
exports.isText = isText;
var _domelementtype = require("domelementtype");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /*#__PURE__*/function () {
  function Node() {
    _classCallCheck(this, Node);
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */
    this.prev = null;
    /** Next sibling */
    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  _createClass(Node, [{
    key: "parentNode",
    get: function get() {
      return this.parent;
    },
    set: function set(parent) {
      this.parent = parent;
    }
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
  }, {
    key: "previousSibling",
    get: function get() {
      return this.prev;
    },
    set: function set(prev) {
      this.prev = prev;
    }
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
  }, {
    key: "nextSibling",
    get: function get() {
      return this.next;
    },
    set: function set(next) {
      this.next = next;
    }
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
  }, {
    key: "cloneNode",
    value: function cloneNode() {
      var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return _cloneNode(this, recursive);
    }
  }]);
  return Node;
}();
/**
 * A node that contains some data.
 */
exports.Node = Node;
var DataNode = /*#__PURE__*/function (_Node) {
  _inherits(DataNode, _Node);
  var _super = _createSuper(DataNode);
  /**
   * @param data The content of the data node
   */
  function DataNode(data) {
    var _this;
    _classCallCheck(this, DataNode);
    _this = _super.call(this);
    _this.data = data;
    return _this;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  _createClass(DataNode, [{
    key: "nodeValue",
    get: function get() {
      return this.data;
    },
    set: function set(data) {
      this.data = data;
    }
  }]);
  return DataNode;
}(Node);
/**
 * Text within the document.
 */
exports.DataNode = DataNode;
var Text = /*#__PURE__*/function (_DataNode) {
  _inherits(Text, _DataNode);
  var _super2 = _createSuper(Text);
  function Text() {
    var _this2;
    _classCallCheck(this, Text);
    _this2 = _super2.apply(this, arguments);
    _this2.type = _domelementtype.ElementType.Text;
    return _this2;
  }
  _createClass(Text, [{
    key: "nodeType",
    get: function get() {
      return 3;
    }
  }]);
  return Text;
}(DataNode);
/**
 * Comments within the document.
 */
exports.Text = Text;
var Comment = /*#__PURE__*/function (_DataNode2) {
  _inherits(Comment, _DataNode2);
  var _super3 = _createSuper(Comment);
  function Comment() {
    var _this3;
    _classCallCheck(this, Comment);
    _this3 = _super3.apply(this, arguments);
    _this3.type = _domelementtype.ElementType.Comment;
    return _this3;
  }
  _createClass(Comment, [{
    key: "nodeType",
    get: function get() {
      return 8;
    }
  }]);
  return Comment;
}(DataNode);
/**
 * Processing instructions, including doc types.
 */
exports.Comment = Comment;
var ProcessingInstruction = /*#__PURE__*/function (_DataNode3) {
  _inherits(ProcessingInstruction, _DataNode3);
  var _super4 = _createSuper(ProcessingInstruction);
  function ProcessingInstruction(name, data) {
    var _this4;
    _classCallCheck(this, ProcessingInstruction);
    _this4 = _super4.call(this, data);
    _this4.name = name;
    _this4.type = _domelementtype.ElementType.Directive;
    return _this4;
  }
  _createClass(ProcessingInstruction, [{
    key: "nodeType",
    get: function get() {
      return 1;
    }
  }]);
  return ProcessingInstruction;
}(DataNode);
/**
 * A `Node` that can have children.
 */
exports.ProcessingInstruction = ProcessingInstruction;
var NodeWithChildren = /*#__PURE__*/function (_Node2) {
  _inherits(NodeWithChildren, _Node2);
  var _super5 = _createSuper(NodeWithChildren);
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  function NodeWithChildren(children) {
    var _this5;
    _classCallCheck(this, NodeWithChildren);
    _this5 = _super5.call(this);
    _this5.children = children;
    return _this5;
  }
  // Aliases
  /** First child of the node. */
  _createClass(NodeWithChildren, [{
    key: "firstChild",
    get: function get() {
      var _a;
      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    }
    /** Last child of the node. */
  }, {
    key: "lastChild",
    get: function get() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    }
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
  }, {
    key: "childNodes",
    get: function get() {
      return this.children;
    },
    set: function set(children) {
      this.children = children;
    }
  }]);
  return NodeWithChildren;
}(Node);
exports.NodeWithChildren = NodeWithChildren;
var CDATA = /*#__PURE__*/function (_NodeWithChildren) {
  _inherits(CDATA, _NodeWithChildren);
  var _super6 = _createSuper(CDATA);
  function CDATA() {
    var _this6;
    _classCallCheck(this, CDATA);
    _this6 = _super6.apply(this, arguments);
    _this6.type = _domelementtype.ElementType.CDATA;
    return _this6;
  }
  _createClass(CDATA, [{
    key: "nodeType",
    get: function get() {
      return 4;
    }
  }]);
  return CDATA;
}(NodeWithChildren);
/**
 * The root node of the document.
 */
exports.CDATA = CDATA;
var Document = /*#__PURE__*/function (_NodeWithChildren2) {
  _inherits(Document, _NodeWithChildren2);
  var _super7 = _createSuper(Document);
  function Document() {
    var _this7;
    _classCallCheck(this, Document);
    _this7 = _super7.apply(this, arguments);
    _this7.type = _domelementtype.ElementType.Root;
    return _this7;
  }
  _createClass(Document, [{
    key: "nodeType",
    get: function get() {
      return 9;
    }
  }]);
  return Document;
}(NodeWithChildren);
/**
 * An element within the DOM.
 */
exports.Document = Document;
var Element = /*#__PURE__*/function (_NodeWithChildren3) {
  _inherits(Element, _NodeWithChildren3);
  var _super8 = _createSuper(Element);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  function Element(name, attribs) {
    var _this8;
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : name === "script" ? _domelementtype.ElementType.Script : name === "style" ? _domelementtype.ElementType.Style : _domelementtype.ElementType.Tag;
    _classCallCheck(this, Element);
    _this8 = _super8.call(this, children);
    _this8.name = name;
    _this8.attribs = attribs;
    _this8.type = type;
    return _this8;
  }
  _createClass(Element, [{
    key: "nodeType",
    get: function get() {
      return 1;
    }
    // DOM Level 1 aliases
    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
  }, {
    key: "tagName",
    get: function get() {
      return this.name;
    },
    set: function set(name) {
      this.name = name;
    }
  }, {
    key: "attributes",
    get: function get() {
      var _this9 = this;
      return Object.keys(this.attribs).map(function (name) {
        var _a, _b;
        return {
          name: name,
          value: _this9.attribs[name],
          namespace: (_a = _this9["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
          prefix: (_b = _this9["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
        };
      });
    }
  }]);
  return Element;
}(NodeWithChildren);
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
exports.Element = Element;
function isTag(node) {
  return (0, _domelementtype.isTag)(node);
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
  return node.type === _domelementtype.ElementType.CDATA;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
  return node.type === _domelementtype.ElementType.Text;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
  return node.type === _domelementtype.ElementType.Comment;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
  return node.type === _domelementtype.ElementType.Directive;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
  return node.type === _domelementtype.ElementType.Root;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function _cloneNode(node) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var result;
  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment(node.data);
  } else if (isTag(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone = new Element(node.name, _objectSpread({}, node.attribs), children);
    children.forEach(function (child) {
      return child.parent = clone;
    });
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = _objectSpread({}, node["x-attribsNamespace"]);
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = _objectSpread({}, node["x-attribsPrefix"]);
    }
    result = clone;
  } else if (isCDATA(node)) {
    var _children = recursive ? cloneChildren(node.children) : [];
    var _clone = new CDATA(_children);
    _children.forEach(function (child) {
      return child.parent = _clone;
    });
    result = _clone;
  } else if (isDocument(node)) {
    var _children2 = recursive ? cloneChildren(node.children) : [];
    var _clone2 = new Document(_children2);
    _children2.forEach(function (child) {
      return child.parent = _clone2;
    });
    if (node["x-mode"]) {
      _clone2["x-mode"] = node["x-mode"];
    }
    result = _clone2;
  } else if (isDirective(node)) {
    var instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node.type));
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  var children = childs.map(function (child) {
    return _cloneNode(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}