"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElementById = getElementById;
exports.getElements = getElements;
exports.getElementsByTagName = getElementsByTagName;
exports.getElementsByTagType = getElementsByTagType;
exports.testElement = testElement;
var _domhandler = require("domhandler");
var _querying = require("./querying.js");
var Checks = {
  tag_name: function tag_name(name) {
    if (typeof name === "function") {
      return function (elem) {
        return (0, _domhandler.isTag)(elem) && name(elem.name);
      };
    } else if (name === "*") {
      return _domhandler.isTag;
    }
    return function (elem) {
      return (0, _domhandler.isTag)(elem) && elem.name === name;
    };
  },
  tag_type: function tag_type(type) {
    if (typeof type === "function") {
      return function (elem) {
        return type(elem.type);
      };
    }
    return function (elem) {
      return elem.type === type;
    };
  },
  tag_contains: function tag_contains(data) {
    if (typeof data === "function") {
      return function (elem) {
        return (0, _domhandler.isText)(elem) && data(elem.data);
      };
    }
    return function (elem) {
      return (0, _domhandler.isText)(elem) && elem.data === data;
    };
  }
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function (elem) {
      return (0, _domhandler.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function (elem) {
    return (0, _domhandler.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs(a, b) {
  return function (elem) {
    return a(elem) || b(elem);
  };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true` if
 *   any of them match a node.
 */
function compileTest(options) {
  var funcs = Object.keys(options).map(function (key) {
    var value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
  var test = compileTest(options);
  return test ? test(node) : true;
}
/**
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse) {
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  var test = compileTest(options);
  return test ? (0, _querying.filter)(test, nodes, recurse, limit) : [];
}
/**
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes) {
  var recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (!Array.isArray(nodes)) nodes = [nodes];
  return (0, _querying.findOne)(getAttribCheck("id", id), nodes, recurse);
}
/**
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes) {
  var recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  return (0, _querying.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
/**
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes) {
  var recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  return (0, _querying.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}