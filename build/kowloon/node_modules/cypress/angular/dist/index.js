"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOutputSpy = exports.CypressTestComponentRenderer = void 0;
exports.mount = mount;
require("zone.js");
require("zone.js/testing");
var _common = require("@angular/common");
var _core = require("@angular/core");
var _testing2 = require("@angular/core/testing");
var _testing3 = require("@angular/platform-browser-dynamic/testing");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); } /**
                                                                                                                                                                                                                                                                                                                                                  * @cypress/angular v0.0.0-development
                                                                                                                                                                                                                                                                                                                                                  * (c) 2023 Cypress.io
                                                                                                                                                                                                                                                                                                                                                  * Released under the MIT License
                                                                                                                                                                                                                                                                                                                                                  */
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var ROOT_SELECTOR = '[data-cy-root]';
/**
 * Gets the root element used to mount the component.
 * @returns {HTMLElement} The root element
 * @throws {Error} If the root element is not found
 */
var getContainerEl = function getContainerEl() {
  var el = document.querySelector(ROOT_SELECTOR);
  if (el) {
    return el;
  }
  throw Error("No element found that matches selector ".concat(ROOT_SELECTOR, ". Please add a root element with data-cy-root attribute to your \"component-index.html\" file so that Cypress can attach your component to the DOM."));
};
/**
 * Utility function to register CT side effects and run cleanup code during the "test:before:run" Cypress hook
 * @param optionalCallback Callback to be called before the next test runs
 */
function setupHooks(optionalCallback) {
  // We don't want CT side effects to run when e2e
  // testing so we early return.
  // System test to verify CT side effects do not pollute e2e: system-tests/test/e2e_with_mount_import_spec.ts
  if (Cypress.testingType !== 'component') {
    return;
  }
  // When running component specs, we cannot allow "cy.visit"
  // because it will wipe out our preparation work, and does not make much sense
  // thus we overwrite "cy.visit" to throw an error
  Cypress.Commands.overwrite('visit', function () {
    throw new Error('cy.visit from a component spec is not allowed');
  });
  Cypress.Commands.overwrite('session', function () {
    throw new Error('cy.session from a component spec is not allowed');
  });
  Cypress.Commands.overwrite('origin', function () {
    throw new Error('cy.origin from a component spec is not allowed');
  });
  // @ts-ignore
  Cypress.on('test:before:run', function () {
    optionalCallback === null || optionalCallback === void 0 ? void 0 : optionalCallback();
  });
}

/**
 * @hack fixes "Mocha has already been patched with Zone" error.
 */
// @ts-ignore
window.Mocha['__zone_patch__'] = false;
var activeFixture = null;
function cleanup() {
  // Not public, we need to call this to remove the last component from the DOM
  try {
    (0, _testing2.getTestBed)().tearDownTestingModule();
  } catch (e) {
    var notSupportedError = new Error("Failed to teardown component. The version of Angular you are using may not be officially supported.");
    notSupportedError.docsUrl = 'https://on.cypress.io/component-framework-configuration';
    throw notSupportedError;
  }
  (0, _testing2.getTestBed)().resetTestingModule();
  activeFixture = null;
}
// 'zone.js/testing' is not properly aliasing `it.skip` but it does provide `xit`/`xspecify`
// Written up under https://github.com/angular/angular/issues/46297 but is not seeing movement
// so we'll patch here pending a fix in that library
globalThis.it.skip = globalThis.xit;
var CypressAngularErrorHandler = /*#__PURE__*/function () {
  function CypressAngularErrorHandler() {
    _classCallCheck(this, CypressAngularErrorHandler);
  }
  _createClass(CypressAngularErrorHandler, [{
    key: "handleError",
    value: function handleError(error) {
      throw error;
    }
  }]);
  return CypressAngularErrorHandler;
}();
CypressAngularErrorHandler = __decorate([(0, _core.Injectable)()], CypressAngularErrorHandler);
/**
 * Bootstraps the TestModuleMetaData passed to the TestBed
 *
 * @param {Type<T>} component Angular component being mounted
 * @param {MountConfig} config TestBed configuration passed into the mount function
 * @returns {MountConfig} MountConfig
 */
function bootstrapModule(component, config) {
  var _a;
  var testModuleMetaData = __rest(config, ["componentProperties"]);
  if (!testModuleMetaData.declarations) {
    testModuleMetaData.declarations = [];
  }
  if (!testModuleMetaData.imports) {
    testModuleMetaData.imports = [];
  }
  if (!testModuleMetaData.providers) {
    testModuleMetaData.providers = [];
  }
  // Replace default error handler since it will swallow uncaught exceptions.
  // We want these to be uncaught so Cypress catches it and fails the test
  testModuleMetaData.providers.push({
    provide: _core.ErrorHandler,
    useClass: CypressAngularErrorHandler
  });
  // check if the component is a standalone component
  if ((_a = component.ɵcmp) === null || _a === void 0 ? void 0 : _a.standalone) {
    testModuleMetaData.imports.push(component);
  } else {
    testModuleMetaData.declarations.push(component);
  }
  if (!testModuleMetaData.imports.includes(_common.CommonModule)) {
    testModuleMetaData.imports.push(_common.CommonModule);
  }
  return testModuleMetaData;
}
var CypressTestComponentRenderer = /*#__PURE__*/function (_TestComponentRendere) {
  _inherits(CypressTestComponentRenderer, _TestComponentRendere);
  var _super = _createSuper(CypressTestComponentRenderer);
  function CypressTestComponentRenderer() {
    _classCallCheck(this, CypressTestComponentRenderer);
    return _super.apply(this, arguments);
  }
  _createClass(CypressTestComponentRenderer, [{
    key: "insertRootElement",
    value: function insertRootElement(rootElId) {
      this.removeAllRootElements();
      var rootElement = getContainerEl();
      rootElement.setAttribute('id', rootElId);
    }
  }, {
    key: "removeAllRootElements",
    value: function removeAllRootElements() {
      getContainerEl().innerHTML = '';
    }
  }]);
  return CypressTestComponentRenderer;
}(_testing2.TestComponentRenderer);
exports.CypressTestComponentRenderer = CypressTestComponentRenderer;
exports.CypressTestComponentRenderer = CypressTestComponentRenderer = __decorate([(0, _core.Injectable)()], CypressTestComponentRenderer);
/**
 * Initializes the TestBed
 *
 * @param {Type<T> | string} component Angular component being mounted or its template
 * @param {MountConfig} config TestBed configuration passed into the mount function
 * @returns {Type<T>} componentFixture
 */
function initTestBed(component, config) {
  var componentFixture = createComponentFixture(component);
  (0, _testing2.getTestBed)().configureTestingModule(Object.assign({}, bootstrapModule(componentFixture, config)));
  (0, _testing2.getTestBed)().overrideProvider(_testing2.TestComponentRenderer, {
    useValue: new CypressTestComponentRenderer()
  });
  return componentFixture;
}
var WrapperComponent = /*#__PURE__*/_createClass(function WrapperComponent() {
  _classCallCheck(this, WrapperComponent);
});
WrapperComponent = __decorate([(0, _core.Component)({
  selector: 'cy-wrapper-component',
  template: ''
})], WrapperComponent);
/**
 * Returns the Component if Type<T> or creates a WrapperComponent
 *
 * @param {Type<T> | string} component The component you want to create a fixture of
 * @returns {Type<T> | WrapperComponent}
 */
function createComponentFixture(component) {
  if (typeof component === 'string') {
    // getTestBed().overrideTemplate is available in v14+
    // The static TestBed.overrideTemplate is available across versions
    _testing2.TestBed.overrideTemplate(WrapperComponent, component);
    return WrapperComponent;
  }
  return component;
}
/**
 * Creates the ComponentFixture
 *
 * @param {Type<T>} component Angular component being mounted
 * @param {MountConfig<T>} config MountConfig

 * @returns {ComponentFixture<T>} ComponentFixture
 */
function setupFixture(component, config) {
  var fixture = (0, _testing2.getTestBed)().createComponent(component);
  setupComponent(config, fixture);
  fixture.whenStable().then(function () {
    var _a;
    fixture.autoDetectChanges((_a = config.autoDetectChanges) !== null && _a !== void 0 ? _a : true);
  });
  return fixture;
}
/**
 * Gets the componentInstance and Object.assigns any componentProperties() passed in the MountConfig
 *
 * @param {MountConfig} config TestBed configuration passed into the mount function
 * @param {ComponentFixture<T>} fixture Fixture for debugging and testing a component.
 * @returns {T} Component being mounted
 */
function setupComponent(config, fixture) {
  var component = fixture.componentInstance;
  if (config === null || config === void 0 ? void 0 : config.componentProperties) {
    component = Object.assign(component, config.componentProperties);
  }
  if (config.autoSpyOutputs) {
    Object.keys(component).forEach(function (key) {
      var property = component[key];
      if (property instanceof _core.EventEmitter) {
        component[key] = createOutputSpy("".concat(key, "Spy"));
      }
    });
  }
  // Manually call ngOnChanges when mounting components using the class syntax.
  // This is necessary because we are assigning input values to the class directly
  // on mount and therefore the ngOnChanges() lifecycle is not triggered.
  if (component.ngOnChanges && config.componentProperties) {
    var componentProperties = config.componentProperties;
    var simpleChanges = Object.entries(componentProperties).reduce(function (acc, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      acc[key] = new _core.SimpleChange(null, value, true);
      return acc;
    }, {});
    if (Object.keys(componentProperties).length > 0) {
      component.ngOnChanges(simpleChanges);
    }
  }
}
/**
 * Mounts an Angular component inside Cypress browser
 *
 * @param component Angular component being mounted or its template
 * @param config configuration used to configure the TestBed
 * @example
 * import { mount } from '@cypress/angular'
 * import { StepperComponent } from './stepper.component'
 * import { MyService } from 'services/my.service'
 * import { SharedModule } from 'shared/shared.module';
 * it('mounts', () => {
 *    mount(StepperComponent, {
 *      providers: [MyService],
 *      imports: [SharedModule]
 *    })
 *    cy.get('[data-cy=increment]').click()
 *    cy.get('[data-cy=counter]').should('have.text', '1')
 * })
 *
 * // or
 *
 * it('mounts with template', () => {
 *   mount('<app-stepper></app-stepper>', {
 *     declarations: [StepperComponent],
 *   })
 * })
 *
 * @see {@link https://on.cypress.io/mounting-angular} for more details.
 *
 * @returns A component and component fixture
 */
function mount(component) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Remove last mounted component if cy.mount is called more than once in a test
  if (activeFixture) {
    cleanup();
  }
  var componentFixture = initTestBed(component, config);
  activeFixture = setupFixture(componentFixture, config);
  var mountResponse = {
    fixture: activeFixture,
    component: activeFixture.componentInstance
  };
  var logMessage = typeof component === 'string' ? 'Component' : componentFixture.name;
  Cypress.log({
    name: 'mount',
    message: logMessage,
    consoleProps: function consoleProps() {
      return {
        result: mountResponse
      };
    }
  });
  return cy.wrap(mountResponse, {
    log: false
  });
}
/**
 * Creates a new Event Emitter and then spies on it's `emit` method
 *
 * @param {string} alias name you want to use for your cy.spy() alias
 * @returns EventEmitter<T>
 * @example
 * import { StepperComponent } from './stepper.component'
 * import { mount, createOutputSpy } from '@cypress/angular'
 *
 * it('Has spy', () => {
 *   mount(StepperComponent, { componentProperties: { change: createOutputSpy('changeSpy') } })
 *   cy.get('[data-cy=increment]').click()
 *   cy.get('@changeSpy').should('have.been.called')
 * })
 */
var createOutputSpy = function createOutputSpy(alias) {
  var emitter = new _core.EventEmitter();
  cy.spy(emitter, 'emit').as(alias);
  return emitter;
};
// Only needs to run once, we reset before each test
exports.createOutputSpy = createOutputSpy;
(0, _testing2.getTestBed)().initTestEnvironment(_testing3.BrowserDynamicTestingModule, (0, _testing3.platformBrowserDynamicTesting)(), {
  teardown: {
    destroyAfterEach: false
  }
});
setupHooks(cleanup);