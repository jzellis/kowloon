"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.EJSON = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.Binary = exports.BSONVersionError = exports.BSONValue = exports.BSONType = exports.BSONSymbol = exports.BSONRuntimeError = exports.BSONRegExp = exports.BSONError = exports.BSON = void 0;
exports.calculateObjectSize = calculateObjectSize;
exports.deserialize = deserialize;
exports.deserializeStream = deserializeStream;
exports.serialize = serialize;
exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
exports.setInternalBufferSize = setInternalBufferSize;
var _Buffer$prototype;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var BSON_MAJOR_VERSION = 5;
var BSON_INT32_MAX = 0x7fffffff;
var BSON_INT32_MIN = -0x80000000;
var BSON_INT64_MAX = Math.pow(2, 63) - 1;
var BSON_INT64_MIN = -Math.pow(2, 63);
var JS_INT_MAX = Math.pow(2, 53);
var JS_INT_MIN = -Math.pow(2, 53);
var BSON_DATA_NUMBER = 1;
var BSON_DATA_STRING = 2;
var BSON_DATA_OBJECT = 3;
var BSON_DATA_ARRAY = 4;
var BSON_DATA_BINARY = 5;
var BSON_DATA_UNDEFINED = 6;
var BSON_DATA_OID = 7;
var BSON_DATA_BOOLEAN = 8;
var BSON_DATA_DATE = 9;
var BSON_DATA_NULL = 10;
var BSON_DATA_REGEXP = 11;
var BSON_DATA_DBPOINTER = 12;
var BSON_DATA_CODE = 13;
var BSON_DATA_SYMBOL = 14;
var BSON_DATA_CODE_W_SCOPE = 15;
var BSON_DATA_INT = 16;
var BSON_DATA_TIMESTAMP = 17;
var BSON_DATA_LONG = 18;
var BSON_DATA_DECIMAL128 = 19;
var BSON_DATA_MIN_KEY = 0xff;
var BSON_DATA_MAX_KEY = 0x7f;
var BSON_BINARY_SUBTYPE_DEFAULT = 0;
var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
var BSONType = Object.freeze({
  "double": 1,
  string: 2,
  object: 3,
  array: 4,
  binData: 5,
  undefined: 6,
  objectId: 7,
  bool: 8,
  date: 9,
  "null": 10,
  regex: 11,
  dbPointer: 12,
  javascript: 13,
  symbol: 14,
  javascriptWithScope: 15,
  "int": 16,
  timestamp: 17,
  "long": 18,
  decimal: 19,
  minKey: -1,
  maxKey: 127
});
exports.BSONType = BSONType;
var BSONError = /*#__PURE__*/function (_Error) {
  _inherits(BSONError, _Error);
  var _super = _createSuper(BSONError);
  function BSONError(message) {
    _classCallCheck(this, BSONError);
    return _super.call(this, message);
  }
  _createClass(BSONError, [{
    key: "bsonError",
    get: function get() {
      return true;
    }
  }, {
    key: "name",
    get: function get() {
      return 'BSONError';
    }
  }], [{
    key: "isBSONError",
    value: function isBSONError(value) {
      return value != null && _typeof(value) === 'object' && 'bsonError' in value && value.bsonError === true && 'name' in value && 'message' in value && 'stack' in value;
    }
  }]);
  return BSONError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.BSONError = BSONError;
var BSONVersionError = /*#__PURE__*/function (_BSONError) {
  _inherits(BSONVersionError, _BSONError);
  var _super2 = _createSuper(BSONVersionError);
  function BSONVersionError() {
    _classCallCheck(this, BSONVersionError);
    return _super2.call(this, "Unsupported BSON version, bson types must be from bson ".concat(BSON_MAJOR_VERSION, ".0 or later"));
  }
  _createClass(BSONVersionError, [{
    key: "name",
    get: function get() {
      return 'BSONVersionError';
    }
  }]);
  return BSONVersionError;
}(BSONError);
exports.BSONVersionError = BSONVersionError;
var BSONRuntimeError = /*#__PURE__*/function (_BSONError2) {
  _inherits(BSONRuntimeError, _BSONError2);
  var _super3 = _createSuper(BSONRuntimeError);
  function BSONRuntimeError(message) {
    _classCallCheck(this, BSONRuntimeError);
    return _super3.call(this, message);
  }
  _createClass(BSONRuntimeError, [{
    key: "name",
    get: function get() {
      return 'BSONRuntimeError';
    }
  }]);
  return BSONRuntimeError;
}(BSONError);
exports.BSONRuntimeError = BSONRuntimeError;
function nodejsMathRandomBytes(byteLength) {
  return nodeJsByteUtils.fromNumberArray(Array.from({
    length: byteLength
  }, function () {
    return Math.floor(Math.random() * 256);
  }));
}
var nodejsRandomBytes = await _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        _context.prev = 0;
        _context.next = 3;
        return Promise.resolve().then(function () {
          return _interopRequireWildcard(require('crypto'));
        });
      case 3:
        return _context.abrupt("return", _context.sent.randomBytes);
      case 6:
        _context.prev = 6;
        _context.t0 = _context["catch"](0);
        return _context.abrupt("return", nodejsMathRandomBytes);
      case 9:
      case "end":
        return _context.stop();
    }
  }, _callee, null, [[0, 6]]);
}))();
var nodeJsByteUtils = {
  toLocalBufferType: function toLocalBufferType(potentialBuffer) {
    var _potentialBuffer$Symb;
    if (Buffer.isBuffer(potentialBuffer)) {
      return potentialBuffer;
    }
    if (ArrayBuffer.isView(potentialBuffer)) {
      return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
    }
    var stringTag = (_potentialBuffer$Symb = potentialBuffer === null || potentialBuffer === void 0 ? void 0 : potentialBuffer[Symbol.toStringTag]) !== null && _potentialBuffer$Symb !== void 0 ? _potentialBuffer$Symb : Object.prototype.toString.call(potentialBuffer);
    if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') {
      return Buffer.from(potentialBuffer);
    }
    throw new BSONError("Cannot create Buffer from ".concat(String(potentialBuffer)));
  },
  allocate: function allocate(size) {
    return Buffer.alloc(size);
  },
  equals: function equals(a, b) {
    return nodeJsByteUtils.toLocalBufferType(a).equals(b);
  },
  fromNumberArray: function fromNumberArray(array) {
    return Buffer.from(array);
  },
  fromBase64: function fromBase64(base64) {
    return Buffer.from(base64, 'base64');
  },
  toBase64: function toBase64(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');
  },
  fromISO88591: function fromISO88591(codePoints) {
    return Buffer.from(codePoints, 'binary');
  },
  toISO88591: function toISO88591(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');
  },
  fromHex: function fromHex(hex) {
    return Buffer.from(hex, 'hex');
  },
  toHex: function toHex(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');
  },
  fromUTF8: function fromUTF8(text) {
    return Buffer.from(text, 'utf8');
  },
  toUTF8: function toUTF8(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8');
  },
  utf8ByteLength: function utf8ByteLength(input) {
    return Buffer.byteLength(input, 'utf8');
  },
  encodeUTF8Into: function encodeUTF8Into(buffer, source, byteOffset) {
    return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');
  },
  randomBytes: nodejsRandomBytes
};
function isReactNative() {
  var navigator = globalThis.navigator;
  return _typeof(navigator) === 'object' && navigator.product === 'ReactNative';
}
function webMathRandomBytes(byteLength) {
  if (byteLength < 0) {
    throw new RangeError("The argument 'byteLength' is invalid. Received ".concat(byteLength));
  }
  return webByteUtils.fromNumberArray(Array.from({
    length: byteLength
  }, function () {
    return Math.floor(Math.random() * 256);
  }));
}
var webRandomBytes = function () {
  var crypto = globalThis.crypto;
  if (crypto != null && typeof crypto.getRandomValues === 'function') {
    return function (byteLength) {
      return crypto.getRandomValues(webByteUtils.allocate(byteLength));
    };
  } else {
    if (isReactNative()) {
      var _console$warn;
      var console = globalThis.console;
      console === null || console === void 0 ? void 0 : (_console$warn = console.warn) === null || _console$warn === void 0 ? void 0 : _console$warn.call(console, 'BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');
    }
    return webMathRandomBytes;
  }
}();
var HEX_DIGIT = /(\d|[a-f])/i;
var webByteUtils = {
  toLocalBufferType: function toLocalBufferType(potentialUint8array) {
    var _potentialUint8array$;
    var stringTag = (_potentialUint8array$ = potentialUint8array === null || potentialUint8array === void 0 ? void 0 : potentialUint8array[Symbol.toStringTag]) !== null && _potentialUint8array$ !== void 0 ? _potentialUint8array$ : Object.prototype.toString.call(potentialUint8array);
    if (stringTag === 'Uint8Array') {
      return potentialUint8array;
    }
    if (ArrayBuffer.isView(potentialUint8array)) {
      return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
    }
    if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') {
      return new Uint8Array(potentialUint8array);
    }
    throw new BSONError("Cannot make a Uint8Array from ".concat(String(potentialUint8array)));
  },
  allocate: function allocate(size) {
    if (typeof size !== 'number') {
      throw new TypeError("The \"size\" argument must be of type number. Received ".concat(String(size)));
    }
    return new Uint8Array(size);
  },
  equals: function equals(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (var i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  },
  fromNumberArray: function fromNumberArray(array) {
    return Uint8Array.from(array);
  },
  fromBase64: function fromBase64(base64) {
    return Uint8Array.from(atob(base64), function (c) {
      return c.charCodeAt(0);
    });
  },
  toBase64: function toBase64(uint8array) {
    return btoa(webByteUtils.toISO88591(uint8array));
  },
  fromISO88591: function fromISO88591(codePoints) {
    return Uint8Array.from(codePoints, function (c) {
      return c.charCodeAt(0) & 0xff;
    });
  },
  toISO88591: function toISO88591(uint8array) {
    return Array.from(Uint16Array.from(uint8array), function (b) {
      return String.fromCharCode(b);
    }).join('');
  },
  fromHex: function fromHex(hex) {
    var evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
    var buffer = [];
    for (var i = 0; i < evenLengthHex.length; i += 2) {
      var firstDigit = evenLengthHex[i];
      var secondDigit = evenLengthHex[i + 1];
      if (!HEX_DIGIT.test(firstDigit)) {
        break;
      }
      if (!HEX_DIGIT.test(secondDigit)) {
        break;
      }
      var hexDigit = Number.parseInt("".concat(firstDigit).concat(secondDigit), 16);
      buffer.push(hexDigit);
    }
    return Uint8Array.from(buffer);
  },
  toHex: function toHex(uint8array) {
    return Array.from(uint8array, function (_byte) {
      return _byte.toString(16).padStart(2, '0');
    }).join('');
  },
  fromUTF8: function fromUTF8(text) {
    return new TextEncoder().encode(text);
  },
  toUTF8: function toUTF8(uint8array) {
    return new TextDecoder('utf8', {
      fatal: false
    }).decode(uint8array);
  },
  utf8ByteLength: function utf8ByteLength(input) {
    return webByteUtils.fromUTF8(input).byteLength;
  },
  encodeUTF8Into: function encodeUTF8Into(buffer, source, byteOffset) {
    var bytes = webByteUtils.fromUTF8(source);
    buffer.set(bytes, byteOffset);
    return bytes.byteLength;
  },
  randomBytes: webRandomBytes
};
var hasGlobalBuffer = typeof Buffer === 'function' && ((_Buffer$prototype = Buffer.prototype) === null || _Buffer$prototype === void 0 ? void 0 : _Buffer$prototype._isBuffer) !== true;
var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
var BSONDataView = /*#__PURE__*/function (_DataView) {
  _inherits(BSONDataView, _DataView);
  var _super4 = _createSuper(BSONDataView);
  function BSONDataView() {
    _classCallCheck(this, BSONDataView);
    return _super4.apply(this, arguments);
  }
  _createClass(BSONDataView, null, [{
    key: "fromUint8Array",
    value: function fromUint8Array(input) {
      return new DataView(input.buffer, input.byteOffset, input.byteLength);
    }
  }]);
  return BSONDataView;
}( /*#__PURE__*/_wrapNativeSuper(DataView));
var VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;
var uuidValidateString = function uuidValidateString(str) {
  return typeof str === 'string' && VALIDATION_REGEX.test(str);
};
var uuidHexStringToBuffer = function uuidHexStringToBuffer(hexString) {
  if (!uuidValidateString(hexString)) {
    throw new BSONError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".');
  }
  var sanitizedHexString = hexString.replace(/-/g, '');
  return ByteUtils.fromHex(sanitizedHexString);
};
function bufferToUuidHexString(buffer) {
  var includeDashes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (includeDashes) {
    return [ByteUtils.toHex(buffer.subarray(0, 4)), ByteUtils.toHex(buffer.subarray(4, 6)), ByteUtils.toHex(buffer.subarray(6, 8)), ByteUtils.toHex(buffer.subarray(8, 10)), ByteUtils.toHex(buffer.subarray(10, 16))].join('-');
  }
  return ByteUtils.toHex(buffer);
}
function isAnyArrayBuffer(value) {
  return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));
}
function isUint8Array(value) {
  return Object.prototype.toString.call(value) === '[object Uint8Array]';
}
function isRegExp(d) {
  return Object.prototype.toString.call(d) === '[object RegExp]';
}
function isMap(d) {
  return Object.prototype.toString.call(d) === '[object Map]';
}
function isDate(d) {
  return Object.prototype.toString.call(d) === '[object Date]';
}
var BSONValue = /*#__PURE__*/function (_Symbol$for) {
  function BSONValue() {
    _classCallCheck(this, BSONValue);
  }
  _createClass(BSONValue, [{
    key: _Symbol$for,
    get: function get() {
      return BSON_MAJOR_VERSION;
    }
  }]);
  return BSONValue;
}(Symbol["for"]('@@mdb.bson.version'));
exports.BSONValue = BSONValue;
var _Binary2 = /*#__PURE__*/function (_BSONValue, _Symbol$for2) {
  _inherits(Binary, _BSONValue);
  var _super5 = _createSuper(Binary);
  function Binary(buffer, subType) {
    var _this;
    _classCallCheck(this, Binary);
    _this = _super5.call(this);
    if (!(buffer == null) && !(typeof buffer === 'string') && !ArrayBuffer.isView(buffer) && !(buffer instanceof ArrayBuffer) && !Array.isArray(buffer)) {
      throw new BSONError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>');
    }
    _this.sub_type = subType !== null && subType !== void 0 ? subType : Binary.BSON_BINARY_SUBTYPE_DEFAULT;
    if (buffer == null) {
      _this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
      _this.position = 0;
    } else {
      if (typeof buffer === 'string') {
        _this.buffer = ByteUtils.fromISO88591(buffer);
      } else if (Array.isArray(buffer)) {
        _this.buffer = ByteUtils.fromNumberArray(buffer);
      } else {
        _this.buffer = ByteUtils.toLocalBufferType(buffer);
      }
      _this.position = _this.buffer.byteLength;
    }
    return _this;
  }
  _createClass(Binary, [{
    key: "_bsontype",
    get: function get() {
      return 'Binary';
    }
  }, {
    key: "put",
    value: function put(byteValue) {
      if (typeof byteValue === 'string' && byteValue.length !== 1) {
        throw new BSONError('only accepts single character String');
      } else if (typeof byteValue !== 'number' && byteValue.length !== 1) throw new BSONError('only accepts single character Uint8Array or Array');
      var decodedByte;
      if (typeof byteValue === 'string') {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === 'number') {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError('only accepts number in a valid unsigned byte range 0-255');
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        var newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
  }, {
    key: "write",
    value: function write(sequence, offset) {
      offset = typeof offset === 'number' ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        var newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === 'string') {
        var bytes = ByteUtils.fromISO88591(sequence);
        this.buffer.set(bytes, offset);
        this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;
      }
    }
  }, {
    key: "read",
    value: function read(position, length) {
      length = length && length > 0 ? length : this.position;
      return this.buffer.slice(position, position + length);
    }
  }, {
    key: "value",
    value: function value(asRaw) {
      asRaw = !!asRaw;
      if (asRaw && this.buffer.length === this.position) {
        return this.buffer;
      }
      if (asRaw) {
        return this.buffer.slice(0, this.position);
      }
      return ByteUtils.toISO88591(this.buffer.subarray(0, this.position));
    }
  }, {
    key: "length",
    value: function length() {
      return this.position;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return ByteUtils.toBase64(this.buffer);
    }
  }, {
    key: "toString",
    value: function toString(encoding) {
      if (encoding === 'hex') return ByteUtils.toHex(this.buffer);
      if (encoding === 'base64') return ByteUtils.toBase64(this.buffer);
      if (encoding === 'utf8' || encoding === 'utf-8') return ByteUtils.toUTF8(this.buffer);
      return ByteUtils.toUTF8(this.buffer);
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      options = options || {};
      var base64String = ByteUtils.toBase64(this.buffer);
      var subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? '0' + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? '0' + subType : subType
        }
      };
    }
  }, {
    key: "toUUID",
    value: function toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.slice(0, this.position));
      }
      throw new BSONError("Binary sub_type \"".concat(this.sub_type, "\" is not supported for converting to UUID. Only \"").concat(Binary.SUBTYPE_UUID, "\" is currently supported."));
    }
  }, {
    key: _Symbol$for2,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new Binary(Buffer.from(\"".concat(ByteUtils.toHex(this.buffer), "\", \"hex\"), ").concat(this.sub_type, ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      options = options || {};
      var data;
      var type;
      if ('$binary' in doc) {
        if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== 'string') {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ('$uuid' in doc) {
        type = 4;
        data = uuidHexStringToBuffer(doc.$uuid);
      }
      if (!data) {
        throw new BSONError("Unexpected Binary Extended JSON format ".concat(JSON.stringify(doc)));
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    }
  }]);
  return Binary;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Binary = _Binary2;
_Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
_Binary2.BUFFER_SIZE = 256;
_Binary2.SUBTYPE_DEFAULT = 0;
_Binary2.SUBTYPE_FUNCTION = 1;
_Binary2.SUBTYPE_BYTE_ARRAY = 2;
_Binary2.SUBTYPE_UUID_OLD = 3;
_Binary2.SUBTYPE_UUID = 4;
_Binary2.SUBTYPE_MD5 = 5;
_Binary2.SUBTYPE_ENCRYPTED = 6;
_Binary2.SUBTYPE_COLUMN = 7;
_Binary2.SUBTYPE_USER_DEFINED = 128;
var UUID_BYTE_LENGTH = 16;
var UUID = /*#__PURE__*/function (_Binary, _Symbol$for3) {
  _inherits(UUID, _Binary);
  var _super6 = _createSuper(UUID);
  function UUID(input) {
    var _this2;
    _classCallCheck(this, UUID);
    var bytes;
    var hexStr;
    if (input == null) {
      bytes = UUID.generate();
    } else if (input instanceof UUID) {
      bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
      hexStr = input.__id;
    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
      bytes = ByteUtils.toLocalBufferType(input);
    } else if (typeof input === 'string') {
      bytes = uuidHexStringToBuffer(input);
    } else {
      throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');
    }
    _this2 = _super6.call(this, bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
    _this2.__id = hexStr;
    return _this2;
  }
  _createClass(UUID, [{
    key: "id",
    get: function get() {
      return this.buffer;
    },
    set: function set(value) {
      this.buffer = value;
      if (UUID.cacheHexString) {
        this.__id = bufferToUuidHexString(value);
      }
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      var includeDashes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (UUID.cacheHexString && this.__id) {
        return this.__id;
      }
      var uuidHexString = bufferToUuidHexString(this.id, includeDashes);
      if (UUID.cacheHexString) {
        this.__id = uuidHexString;
      }
      return uuidHexString;
    }
  }, {
    key: "toString",
    value: function toString(encoding) {
      if (encoding === 'hex') return ByteUtils.toHex(this.id);
      if (encoding === 'base64') return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toHexString();
    }
  }, {
    key: "equals",
    value: function equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch (_unused2) {
        return false;
      }
    }
  }, {
    key: "toBinary",
    value: function toBinary() {
      return new _Binary2(this.id, _Binary2.SUBTYPE_UUID);
    }
  }, {
    key: _Symbol$for3,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new UUID(\"".concat(this.toHexString(), "\")");
    }
  }], [{
    key: "generate",
    value: function generate() {
      var bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 0x0f | 0x40;
      bytes[8] = bytes[8] & 0x3f | 0x80;
      return bytes;
    }
  }, {
    key: "isValid",
    value: function isValid(input) {
      if (!input) {
        return false;
      }
      if (input instanceof UUID) {
        return true;
      }
      if (typeof input === 'string') {
        return uuidValidateString(input);
      }
      if (isUint8Array(input)) {
        if (input.byteLength !== UUID_BYTE_LENGTH) {
          return false;
        }
        return (input[6] & 0xf0) === 0x40 && (input[8] & 0x80) === 0x80;
      }
      return false;
    }
  }, {
    key: "createFromHexString",
    value: function createFromHexString(hexString) {
      var buffer = uuidHexStringToBuffer(hexString);
      return new UUID(buffer);
    }
  }]);
  return UUID;
}(_Binary2, Symbol["for"]('nodejs.util.inspect.custom'));
exports.UUID = UUID;
var _Code = /*#__PURE__*/function (_BSONValue2, _Symbol$for4) {
  _inherits(Code, _BSONValue2);
  var _super7 = _createSuper(Code);
  function Code(code, scope) {
    var _this3;
    _classCallCheck(this, Code);
    _this3 = _super7.call(this);
    _this3.code = code.toString();
    _this3.scope = scope !== null && scope !== void 0 ? scope : null;
    return _this3;
  }
  _createClass(Code, [{
    key: "_bsontype",
    get: function get() {
      return 'Code';
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (this.scope != null) {
        return {
          code: this.code,
          scope: this.scope
        };
      }
      return {
        code: this.code
      };
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      if (this.scope) {
        return {
          $code: this.code,
          $scope: this.scope
        };
      }
      return {
        $code: this.code
      };
    }
  }, {
    key: _Symbol$for4,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      var codeJson = this.toJSON();
      return "new Code(\"".concat(String(codeJson.code), "\"").concat(codeJson.scope != null ? ", ".concat(JSON.stringify(codeJson.scope)) : '', ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
  }]);
  return Code;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Code = _Code;
function isDBRefLike(value) {
  return value != null && _typeof(value) === 'object' && '$id' in value && value.$id != null && '$ref' in value && typeof value.$ref === 'string' && (!('$db' in value) || '$db' in value && typeof value.$db === 'string');
}
var _DBRef = /*#__PURE__*/function (_BSONValue3, _Symbol$for5) {
  _inherits(DBRef, _BSONValue3);
  var _super8 = _createSuper(DBRef);
  function DBRef(collection, oid, db, fields) {
    var _this4;
    _classCallCheck(this, DBRef);
    _this4 = _super8.call(this);
    var parts = collection.split('.');
    if (parts.length === 2) {
      db = parts.shift();
      collection = parts.shift();
    }
    _this4.collection = collection;
    _this4.oid = oid;
    _this4.db = db;
    _this4.fields = fields || {};
    return _this4;
  }
  _createClass(DBRef, [{
    key: "_bsontype",
    get: function get() {
      return 'DBRef';
    }
  }, {
    key: "namespace",
    get: function get() {
      return this.collection;
    },
    set: function set(value) {
      this.collection = value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var o = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null) o.$db = this.db;
      return o;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      options = options || {};
      var o = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o;
      }
      if (this.db) o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    }
  }, {
    key: _Symbol$for5,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      var oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();
      return "new DBRef(\"".concat(this.namespace, "\", new ObjectId(\"").concat(String(oid), "\")").concat(this.db ? ", \"".concat(this.db, "\"") : '', ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      var copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
  }]);
  return DBRef;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.DBRef = _DBRef;
var wasm = undefined;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (_unused3) {}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var INT_CACHE = {};
var UINT_CACHE = {};
var MAX_INT64_STRING_LENGTH = 20;
var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
var _Long = /*#__PURE__*/function (_BSONValue4, _Symbol$for6) {
  _inherits(Long, _BSONValue4);
  var _super9 = _createSuper(Long);
  function Long() {
    var _this5;
    var low = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var high = arguments.length > 1 ? arguments[1] : undefined;
    var unsigned = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, Long);
    _this5 = _super9.call(this);
    if (typeof low === 'bigint') {
      Object.assign(_assertThisInitialized(_this5), Long.fromBigInt(low, !!high));
    } else if (typeof low === 'string') {
      Object.assign(_assertThisInitialized(_this5), Long.fromString(low, !!high));
    } else {
      _this5.low = low | 0;
      _this5.high = high | 0;
      _this5.unsigned = !!unsigned;
    }
    return _this5;
  }
  _createClass(Long, [{
    key: "_bsontype",
    get: function get() {
      return 'Long';
    }
  }, {
    key: "__isLong__",
    get: function get() {
      return true;
    }
  }, {
    key: "add",
    value: function add(addend) {
      if (!Long.isLong(addend)) addend = Long.fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
  }, {
    key: "and",
    value: function and(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
  }, {
    key: "compare",
    value: function compare(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      if (this.eq(other)) return 0;
      var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1;
      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
  }, {
    key: "comp",
    value: function comp(other) {
      return this.compare(other);
    }
  }, {
    key: "divide",
    value: function divide(divisor) {
      if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);
      if (divisor.isZero()) throw new BSONError('division by zero');
      if (wasm) {
        if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative()) return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return Long.UZERO;
        if (divisor.gt(this.shru(1))) return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long.fromNumber(approx);
        var approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero()) approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
  }, {
    key: "div",
    value: function div(divisor) {
      return this.divide(divisor);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
      return this.high === other.high && this.low === other.low;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.equals(other);
    }
  }, {
    key: "getHighBits",
    value: function getHighBits() {
      return this.high;
    }
  }, {
    key: "getHighBitsUnsigned",
    value: function getHighBitsUnsigned() {
      return this.high >>> 0;
    }
  }, {
    key: "getLowBits",
    value: function getLowBits() {
      return this.low;
    }
  }, {
    key: "getLowBitsUnsigned",
    value: function getLowBitsUnsigned() {
      return this.low >>> 0;
    }
  }, {
    key: "getNumBitsAbs",
    value: function getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      var val = this.high !== 0 ? this.high : this.low;
      var bit;
      for (bit = 31; bit > 0; bit--) if ((val & 1 << bit) !== 0) break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
  }, {
    key: "greaterThan",
    value: function greaterThan(other) {
      return this.comp(other) > 0;
    }
  }, {
    key: "gt",
    value: function gt(other) {
      return this.greaterThan(other);
    }
  }, {
    key: "greaterThanOrEqual",
    value: function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
  }, {
    key: "gte",
    value: function gte(other) {
      return this.greaterThanOrEqual(other);
    }
  }, {
    key: "ge",
    value: function ge(other) {
      return this.greaterThanOrEqual(other);
    }
  }, {
    key: "isEven",
    value: function isEven() {
      return (this.low & 1) === 0;
    }
  }, {
    key: "isNegative",
    value: function isNegative() {
      return !this.unsigned && this.high < 0;
    }
  }, {
    key: "isOdd",
    value: function isOdd() {
      return (this.low & 1) === 1;
    }
  }, {
    key: "isPositive",
    value: function isPositive() {
      return this.unsigned || this.high >= 0;
    }
  }, {
    key: "isZero",
    value: function isZero() {
      return this.high === 0 && this.low === 0;
    }
  }, {
    key: "lessThan",
    value: function lessThan(other) {
      return this.comp(other) < 0;
    }
  }, {
    key: "lt",
    value: function lt(other) {
      return this.lessThan(other);
    }
  }, {
    key: "lessThanOrEqual",
    value: function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
  }, {
    key: "lte",
    value: function lte(other) {
      return this.lessThanOrEqual(other);
    }
  }, {
    key: "modulo",
    value: function modulo(divisor) {
      if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
  }, {
    key: "mod",
    value: function mod(divisor) {
      return this.modulo(divisor);
    }
  }, {
    key: "rem",
    value: function rem(divisor) {
      return this.modulo(divisor);
    }
  }, {
    key: "multiply",
    value: function multiply(multiplier) {
      if (this.isZero()) return Long.ZERO;
      if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero()) return Long.ZERO;
      if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
  }, {
    key: "mul",
    value: function mul(multiplier) {
      return this.multiply(multiplier);
    }
  }, {
    key: "negate",
    value: function negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
  }, {
    key: "neg",
    value: function neg() {
      return this.negate();
    }
  }, {
    key: "not",
    value: function not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
  }, {
    key: "notEquals",
    value: function notEquals(other) {
      return !this.equals(other);
    }
  }, {
    key: "neq",
    value: function neq(other) {
      return this.notEquals(other);
    }
  }, {
    key: "ne",
    value: function ne(other) {
      return this.notEquals(other);
    }
  }, {
    key: "or",
    value: function or(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
  }, {
    key: "shiftLeft",
    value: function shiftLeft(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
  }, {
    key: "shl",
    value: function shl(numBits) {
      return this.shiftLeft(numBits);
    }
  }, {
    key: "shiftRight",
    value: function shiftRight(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
  }, {
    key: "shr",
    value: function shr(numBits) {
      return this.shiftRight(numBits);
    }
  }, {
    key: "shiftRightUnsigned",
    value: function shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0) return this;else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
  }, {
    key: "shr_u",
    value: function shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
  }, {
    key: "shru",
    value: function shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
  }, {
    key: "subtract",
    value: function subtract(subtrahend) {
      if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
  }, {
    key: "sub",
    value: function sub(subtrahend) {
      return this.subtract(subtrahend);
    }
  }, {
    key: "toInt",
    value: function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
  }, {
    key: "toBigInt",
    value: function toBigInt() {
      return BigInt(this.toString());
    }
  }, {
    key: "toBytes",
    value: function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
  }, {
    key: "toBytesLE",
    value: function toBytesLE() {
      var hi = this.high,
        lo = this.low;
      return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
    }
  }, {
    key: "toBytesBE",
    value: function toBytesBE() {
      var hi = this.high,
        lo = this.low;
      return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
    }
  }, {
    key: "toSigned",
    value: function toSigned() {
      if (!this.unsigned) return this;
      return Long.fromBits(this.low, this.high, false);
    }
  }, {
    key: "toString",
    value: function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw new BSONError('radix');
      if (this.isZero()) return '0';
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          var radixLong = Long.fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else return '-' + this.neg().toString(radix);
      }
      var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      var rem = this;
      var result = '';
      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) digits = '0' + digits;
          result = '' + digits + result;
        }
      }
    }
  }, {
    key: "toUnsigned",
    value: function toUnsigned() {
      if (this.unsigned) return this;
      return Long.fromBits(this.low, this.high, true);
    }
  }, {
    key: "xor",
    value: function xor(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
  }, {
    key: "eqz",
    value: function eqz() {
      return this.isZero();
    }
  }, {
    key: "le",
    value: function le(other) {
      return this.lessThanOrEqual(other);
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      if (options && options.relaxed) return this.toNumber();
      return {
        $numberLong: this.toString()
      };
    }
  }, {
    key: _Symbol$for6,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new Long(\"".concat(this.toString(), "\"").concat(this.unsigned ? ', true' : '', ")");
    }
  }], [{
    key: "fromBits",
    value: function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
  }, {
    key: "fromInt",
    value: function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache) UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) INT_CACHE[value] = obj;
        return obj;
      }
    }
  }, {
    key: "fromNumber",
    value: function fromNumber(value, unsigned) {
      if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value < 0) return Long.UZERO;
        if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;
      }
      if (value < 0) return Long.fromNumber(-value, unsigned).neg();
      return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
  }, {
    key: "fromBigInt",
    value: function fromBigInt(value, unsigned) {
      return Long.fromString(value.toString(), unsigned);
    }
  }, {
    key: "fromString",
    value: function fromString(str, unsigned, radix) {
      if (str.length === 0) throw new BSONError('empty string');
      if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') return Long.ZERO;
      if (typeof unsigned === 'number') {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw new BSONError('radix');
      var p;
      if ((p = str.indexOf('-')) > 0) throw new BSONError('interior hyphen');else if (p === 0) {
        return Long.fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = Long.fromNumber(Math.pow(radix, 8));
      var result = Long.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
  }, {
    key: "fromBytes",
    value: function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
  }, {
    key: "fromBytesLE",
    value: function fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
  }, {
    key: "fromBytesBE",
    value: function fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
  }, {
    key: "isLong",
    value: function isLong(value) {
      return value != null && _typeof(value) === 'object' && '__isLong__' in value && value.__isLong__ === true;
    }
  }, {
    key: "fromValue",
    value: function fromValue(val, unsigned) {
      if (typeof val === 'number') return Long.fromNumber(val, unsigned);
      if (typeof val === 'string') return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      var _options = _objectSpread({}, options),
        _options$useBigInt = _options.useBigInt64,
        useBigInt64 = _options$useBigInt === void 0 ? false : _options$useBigInt,
        _options$relaxed = _options.relaxed,
        relaxed = _options$relaxed === void 0 ? true : _options$relaxed;
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError('$numberLong string is too long');
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError("$numberLong string \"".concat(doc.$numberLong, "\" is in an invalid format"));
      }
      if (useBigInt64) {
        var bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      var longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
  }]);
  return Long;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Long = _Long;
_Long.TWO_PWR_24 = _Long.fromInt(TWO_PWR_24_DBL);
_Long.MAX_UNSIGNED_VALUE = _Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);
_Long.ZERO = _Long.fromInt(0);
_Long.UZERO = _Long.fromInt(0, true);
_Long.ONE = _Long.fromInt(1);
_Long.UONE = _Long.fromInt(1, true);
_Long.NEG_ONE = _Long.fromInt(-1);
_Long.MAX_VALUE = _Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);
_Long.MIN_VALUE = _Long.fromBits(0, 0x80000000 | 0, false);
var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
var EXPONENT_MAX = 6111;
var EXPONENT_MIN = -6176;
var EXPONENT_BIAS = 6176;
var MAX_DIGITS = 34;
var NAN_BUFFER = ByteUtils.fromNumberArray([0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());
var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());
var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());
var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
var COMBINATION_MASK = 0x1f;
var EXPONENT_MASK = 0x3fff;
var COMBINATION_INFINITY = 30;
var COMBINATION_NAN = 31;
function isDigit(value) {
  return !isNaN(parseInt(value, 10));
}
function divideu128(value) {
  var DIVISOR = _Long.fromNumber(1000 * 1000 * 1000);
  var _rem = _Long.fromNumber(0);
  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
    return {
      quotient: value,
      rem: _rem
    };
  }
  for (var i = 0; i <= 3; i++) {
    _rem = _rem.shiftLeft(32);
    _rem = _rem.add(new _Long(value.parts[i], 0));
    value.parts[i] = _rem.div(DIVISOR).low;
    _rem = _rem.modulo(DIVISOR);
  }
  return {
    quotient: value,
    rem: _rem
  };
}
function multiply64x2(left, right) {
  if (!left && !right) {
    return {
      high: _Long.fromNumber(0),
      low: _Long.fromNumber(0)
    };
  }
  var leftHigh = left.shiftRightUnsigned(32);
  var leftLow = new _Long(left.getLowBits(), 0);
  var rightHigh = right.shiftRightUnsigned(32);
  var rightLow = new _Long(right.getLowBits(), 0);
  var productHigh = leftHigh.multiply(rightHigh);
  var productMid = leftHigh.multiply(rightLow);
  var productMid2 = leftLow.multiply(rightHigh);
  var productLow = leftLow.multiply(rightLow);
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productMid = new _Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productLow = productMid.shiftLeft(32).add(new _Long(productLow.getLowBits(), 0));
  return {
    high: productHigh,
    low: productLow
  };
}
function lessThan(left, right) {
  var uhleft = left.high >>> 0;
  var uhright = right.high >>> 0;
  if (uhleft < uhright) {
    return true;
  } else if (uhleft === uhright) {
    var ulleft = left.low >>> 0;
    var ulright = right.low >>> 0;
    if (ulleft < ulright) return true;
  }
  return false;
}
function invalidErr(string, message) {
  throw new BSONError("\"".concat(string, "\" is not a valid Decimal128 string - ").concat(message));
}
var _Decimal = /*#__PURE__*/function (_BSONValue5, _Symbol$for7) {
  _inherits(Decimal128, _BSONValue5);
  var _super10 = _createSuper(Decimal128);
  function Decimal128(bytes) {
    var _this6;
    _classCallCheck(this, Decimal128);
    _this6 = _super10.call(this);
    if (typeof bytes === 'string') {
      _this6.bytes = Decimal128.fromString(bytes).bytes;
    } else if (isUint8Array(bytes)) {
      if (bytes.byteLength !== 16) {
        throw new BSONError('Decimal128 must take a Buffer of 16 bytes');
      }
      _this6.bytes = bytes;
    } else {
      throw new BSONError('Decimal128 must take a Buffer or string');
    }
    return _this6;
  }
  _createClass(Decimal128, [{
    key: "_bsontype",
    get: function get() {
      return 'Decimal128';
    }
  }, {
    key: "toString",
    value: function toString() {
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++) significand[i] = 0;
      var index = 0;
      var is_zero = false;
      var significand_msb;
      var significand128 = {
        parts: [0, 0, 0, 0]
      };
      var j, k;
      var string = [];
      index = 0;
      var buffer = this.bytes;
      var low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      index = 0;
      var dec = {
        low: new _Long(low, midl),
        high: new _Long(midh, high)
      };
      if (dec.high.lessThan(_Long.ZERO)) {
        string.push('-');
      }
      var combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join('') + 'Infinity';
        } else if (combination === COMBINATION_NAN) {
          return 'NaN';
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 0x08 + (high >> 14 & 0x01);
        }
      } else {
        significand_msb = high >> 14 & 0x07;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      var exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits) continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      var scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push("".concat(0));
          if (exponent > 0) string.push("E+".concat(exponent));else if (exponent < 0) string.push("E".concat(exponent));
          return string.join('');
        }
        string.push("".concat(significand[index++]));
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push('.');
        }
        for (var _i = 0; _i < significand_digits; _i++) {
          string.push("".concat(significand[index++]));
        }
        string.push('E');
        if (scientific_exponent > 0) {
          string.push("+".concat(scientific_exponent));
        } else {
          string.push("".concat(scientific_exponent));
        }
      } else {
        if (exponent >= 0) {
          for (var _i2 = 0; _i2 < significand_digits; _i2++) {
            string.push("".concat(significand[index++]));
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (var _i3 = 0; _i3 < radix_position; _i3++) {
              string.push("".concat(significand[index++]));
            }
          } else {
            string.push('0');
          }
          string.push('.');
          while (radix_position++ < 0) {
            string.push('0');
          }
          for (var _i4 = 0; _i4 < significand_digits - Math.max(radix_position - 1, 0); _i4++) {
            string.push("".concat(significand[index++]));
          }
        }
      }
      return string.join('');
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        $numberDecimal: this.toString()
      };
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $numberDecimal: this.toString()
      };
    }
  }, {
    key: _Symbol$for7,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new Decimal128(\"".concat(this.toString(), "\")");
    }
  }], [{
    key: "fromString",
    value: function fromString(representation) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = new _Long(0, 0);
      var significandLow = new _Long(0, 0);
      var biasedExponent = 0;
      var index = 0;
      if (representation.length >= 7000) {
        throw new BSONError('' + representation + ' not a valid Decimal128 string');
      }
      var stringMatch = representation.match(PARSE_STRING_REGEXP);
      var infMatch = representation.match(PARSE_INF_REGEXP);
      var nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError('' + representation + ' not a valid Decimal128 string');
      }
      if (stringMatch) {
        var unsignedNumber = stringMatch[2];
        var e = stringMatch[4];
        var expSign = stringMatch[5];
        var expNumber = stringMatch[6];
        if (e && expNumber === undefined) invalidErr(representation, 'missing exponent power');
        if (e && unsignedNumber === undefined) invalidErr(representation, 'missing exponent base');
        if (e === undefined && (expSign || expNumber)) {
          invalidErr(representation, 'missing e before exponent');
        }
      }
      if (representation[index] === '+' || representation[index] === '-') {
        isNegative = representation[index++] === '-';
      }
      if (!isDigit(representation[index]) && representation[index] !== '.') {
        if (representation[index] === 'i' || representation[index] === 'I') {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === 'N') {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === '.') {
        if (representation[index] === '.') {
          if (sawRadix) invalidErr(representation, 'contains multiple periods');
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (representation[index] !== '0' || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) nDigits = nDigits + 1;
        if (sawRadix) radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead) throw new BSONError('' + representation + ' not a valid Decimal128 string');
      if (representation[index] === 'e' || representation[index] === 'E') {
        var match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2]) return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index]) return new Decimal128(NAN_BUFFER);
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (digits[firstNonZero + significantDigits - 1] === 0) {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join('');
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, 'overflow');
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0 && significantDigits < nDigitsStored) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          var _digitsString = digits.join('');
          if (_digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, 'overflow');
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits) {
        var endOfString = nDigitsRead;
        if (sawRadix) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        if (isNegative) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(representation[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                }
              }
            }
          }
        }
      }
      significandHigh = _Long.fromNumber(0);
      significandLow = _Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = _Long.fromNumber(0);
        significandLow = _Long.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        var _dIdx = firstDigit;
        significandLow = _Long.fromNumber(digits[_dIdx++]);
        significandHigh = new _Long(0, 0);
        for (; _dIdx <= lastDigit; _dIdx++) {
          significandLow = significandLow.multiply(_Long.fromNumber(10));
          significandLow = significandLow.add(_Long.fromNumber(digits[_dIdx]));
        }
      } else {
        var _dIdx2 = firstDigit;
        significandHigh = _Long.fromNumber(digits[_dIdx2++]);
        for (; _dIdx2 <= lastDigit - 17; _dIdx2++) {
          significandHigh = significandHigh.multiply(_Long.fromNumber(10));
          significandHigh = significandHigh.add(_Long.fromNumber(digits[_dIdx2]));
        }
        significandLow = _Long.fromNumber(digits[_dIdx2++]);
        for (; _dIdx2 <= lastDigit; _dIdx2++) {
          significandLow = significandLow.multiply(_Long.fromNumber(10));
          significandLow = significandLow.add(_Long.fromNumber(digits[_dIdx2]));
        }
      }
      var significand = multiply64x2(significandHigh, _Long.fromString('100000000000000000'));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(_Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = {
        low: _Long.fromNumber(0),
        high: _Long.fromNumber(0)
      };
      if (significand.high.shiftRightUnsigned(49).and(_Long.fromNumber(1)).equals(_Long.fromNumber(1))) {
        dec.high = dec.high.or(_Long.fromNumber(0x3).shiftLeft(61));
        dec.high = dec.high.or(_Long.fromNumber(biasedExponent).and(_Long.fromNumber(0x3fff).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(_Long.fromNumber(0x7fffffffffff)));
      } else {
        dec.high = dec.high.or(_Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(_Long.fromNumber(0x1ffffffffffff)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(_Long.fromString('9223372036854775808'));
      }
      var buffer = ByteUtils.allocate(16);
      index = 0;
      buffer[index++] = dec.low.low & 0xff;
      buffer[index++] = dec.low.low >> 8 & 0xff;
      buffer[index++] = dec.low.low >> 16 & 0xff;
      buffer[index++] = dec.low.low >> 24 & 0xff;
      buffer[index++] = dec.low.high & 0xff;
      buffer[index++] = dec.low.high >> 8 & 0xff;
      buffer[index++] = dec.low.high >> 16 & 0xff;
      buffer[index++] = dec.low.high >> 24 & 0xff;
      buffer[index++] = dec.high.low & 0xff;
      buffer[index++] = dec.high.low >> 8 & 0xff;
      buffer[index++] = dec.high.low >> 16 & 0xff;
      buffer[index++] = dec.high.low >> 24 & 0xff;
      buffer[index++] = dec.high.high & 0xff;
      buffer[index++] = dec.high.high >> 8 & 0xff;
      buffer[index++] = dec.high.high >> 16 & 0xff;
      buffer[index++] = dec.high.high >> 24 & 0xff;
      return new Decimal128(buffer);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
  }]);
  return Decimal128;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Decimal128 = _Decimal;
var _Double = /*#__PURE__*/function (_BSONValue6, _Symbol$for8) {
  _inherits(Double, _BSONValue6);
  var _super11 = _createSuper(Double);
  function Double(value) {
    var _this7;
    _classCallCheck(this, Double);
    _this7 = _super11.call(this);
    if (value instanceof Number) {
      value = value.valueOf();
    }
    _this7.value = +value;
    return _this7;
  }
  _createClass(Double, [{
    key: "_bsontype",
    get: function get() {
      return 'Double';
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: "toString",
    value: function toString(radix) {
      return this.value.toString(radix);
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return {
          $numberDouble: '-0.0'
        };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
  }, {
    key: _Symbol$for8,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      var eJSON = this.toExtendedJSON();
      return "new Double(".concat(eJSON.$numberDouble, ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      var doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
  }]);
  return Double;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Double = _Double;
var _Int = /*#__PURE__*/function (_BSONValue7, _Symbol$for9) {
  _inherits(Int32, _BSONValue7);
  var _super12 = _createSuper(Int32);
  function Int32(value) {
    var _this8;
    _classCallCheck(this, Int32);
    _this8 = _super12.call(this);
    if (value instanceof Number) {
      value = value.valueOf();
    }
    _this8.value = +value | 0;
    return _this8;
  }
  _createClass(Int32, [{
    key: "_bsontype",
    get: function get() {
      return 'Int32';
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toString",
    value: function toString(radix) {
      return this.value.toString(radix);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy)) return this.value;
      return {
        $numberInt: this.value.toString()
      };
    }
  }, {
    key: _Symbol$for9,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new Int32(".concat(this.valueOf(), ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
  }]);
  return Int32;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Int32 = _Int;
var _MaxKey = /*#__PURE__*/function (_BSONValue8, _Symbol$for10) {
  _inherits(MaxKey, _BSONValue8);
  var _super13 = _createSuper(MaxKey);
  function MaxKey() {
    _classCallCheck(this, MaxKey);
    return _super13.apply(this, arguments);
  }
  _createClass(MaxKey, [{
    key: "_bsontype",
    get: function get() {
      return 'MaxKey';
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $maxKey: 1
      };
    }
  }, {
    key: _Symbol$for10,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return 'new MaxKey()';
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON() {
      return new MaxKey();
    }
  }]);
  return MaxKey;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.MaxKey = _MaxKey;
var _MinKey = /*#__PURE__*/function (_BSONValue9, _Symbol$for11) {
  _inherits(MinKey, _BSONValue9);
  var _super14 = _createSuper(MinKey);
  function MinKey() {
    _classCallCheck(this, MinKey);
    return _super14.apply(this, arguments);
  }
  _createClass(MinKey, [{
    key: "_bsontype",
    get: function get() {
      return 'MinKey';
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $minKey: 1
      };
    }
  }, {
    key: _Symbol$for11,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return 'new MinKey()';
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON() {
      return new MinKey();
    }
  }]);
  return MinKey;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.MinKey = _MinKey;
var checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');
var PROCESS_UNIQUE = null;
var kId = Symbol('id');
var _ObjectId = /*#__PURE__*/function (_BSONValue10, _Symbol$for12) {
  _inherits(ObjectId, _BSONValue10);
  var _super15 = _createSuper(ObjectId);
  function ObjectId(inputId) {
    var _this9;
    _classCallCheck(this, ObjectId);
    _this9 = _super15.call(this);
    var workingId;
    if (_typeof(inputId) === 'object' && inputId && 'id' in inputId) {
      if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {
        throw new BSONError('Argument passed in must have an id that is of type string or Buffer');
      }
      if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {
        workingId = ByteUtils.fromHex(inputId.toHexString());
      } else {
        workingId = inputId.id;
      }
    } else {
      workingId = inputId;
    }
    if (workingId == null || typeof workingId === 'number') {
      _this9[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);
    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
      _this9[kId] = ByteUtils.toLocalBufferType(workingId);
    } else if (typeof workingId === 'string') {
      if (workingId.length === 12) {
        var bytes = ByteUtils.fromUTF8(workingId);
        if (bytes.byteLength === 12) {
          _this9[kId] = bytes;
        } else {
          throw new BSONError('Argument passed in must be a string of 12 bytes');
        }
      } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
        _this9[kId] = ByteUtils.fromHex(workingId);
      } else {
        throw new BSONError('Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer');
      }
    } else {
      throw new BSONError('Argument passed in does not match the accepted types');
    }
    if (ObjectId.cacheHexString) {
      _this9.__id = ByteUtils.toHex(_this9.id);
    }
    return _this9;
  }
  _createClass(ObjectId, [{
    key: "_bsontype",
    get: function get() {
      return 'ObjectId';
    }
  }, {
    key: "id",
    get: function get() {
      return this[kId];
    },
    set: function set(value) {
      this[kId] = value;
      if (ObjectId.cacheHexString) {
        this.__id = ByteUtils.toHex(value);
      }
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      if (ObjectId.cacheHexString && this.__id) {
        return this.__id;
      }
      var hexString = ByteUtils.toHex(this.id);
      if (ObjectId.cacheHexString && !this.__id) {
        this.__id = hexString;
      }
      return hexString;
    }
  }, {
    key: "toString",
    value: function toString(encoding) {
      if (encoding === 'base64') return ByteUtils.toBase64(this.id);
      if (encoding === 'hex') return this.toHexString();
      return this.toHexString();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toHexString();
    }
  }, {
    key: "equals",
    value: function equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (otherId instanceof ObjectId) {
        return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);
      }
      if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {
        return ByteUtils.equals(this.id, ByteUtils.fromISO88591(otherId));
      }
      if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {
        return ByteUtils.equals(ByteUtils.fromUTF8(otherId), this.id);
      }
      if (_typeof(otherId) === 'object' && 'toHexString' in otherId && typeof otherId.toHexString === 'function') {
        var otherIdString = otherId.toHexString();
        var thisIdString = this.toHexString().toLowerCase();
        return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
  }, {
    key: "getTimestamp",
    value: function getTimestamp() {
      var timestamp = new Date();
      var time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      if (this.toHexString) return {
        $oid: this.toHexString()
      };
      return {
        $oid: this.toString('hex')
      };
    }
  }, {
    key: _Symbol$for12,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new ObjectId(\"".concat(this.toHexString(), "\")");
    }
  }], [{
    key: "getInc",
    value: function getInc() {
      return ObjectId.index = (ObjectId.index + 1) % 0xffffff;
    }
  }, {
    key: "generate",
    value: function generate(time) {
      if ('number' !== typeof time) {
        time = Math.floor(Date.now() / 1000);
      }
      var inc = ObjectId.getInc();
      var buffer = ByteUtils.allocate(12);
      BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer[4] = PROCESS_UNIQUE[0];
      buffer[5] = PROCESS_UNIQUE[1];
      buffer[6] = PROCESS_UNIQUE[2];
      buffer[7] = PROCESS_UNIQUE[3];
      buffer[8] = PROCESS_UNIQUE[4];
      buffer[11] = inc & 0xff;
      buffer[10] = inc >> 8 & 0xff;
      buffer[9] = inc >> 16 & 0xff;
      return buffer;
    }
  }, {
    key: "createPk",
    value: function createPk() {
      return new ObjectId();
    }
  }, {
    key: "createFromTime",
    value: function createFromTime(time) {
      var buffer = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);
      return new ObjectId(buffer);
    }
  }, {
    key: "createFromHexString",
    value: function createFromHexString(hexString) {
      if (typeof hexString === 'undefined' || hexString != null && hexString.length !== 24) {
        throw new BSONError('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
      }
      return new ObjectId(ByteUtils.fromHex(hexString));
    }
  }, {
    key: "isValid",
    value: function isValid(id) {
      if (id == null) return false;
      try {
        new ObjectId(id);
        return true;
      } catch (_unused4) {
        return false;
      }
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return new ObjectId(doc.$oid);
    }
  }]);
  return ObjectId;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.ObjectId = _ObjectId;
_ObjectId.index = Math.floor(Math.random() * 0xffffff);
function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
  var totalLength = 4 + 1;
  if (Array.isArray(object)) {
    for (var i = 0; i < object.length; i++) {
      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
    }
  } else {
    var _object;
    if (typeof ((_object = object) === null || _object === void 0 ? void 0 : _object.toBSON) === 'function') {
      object = object.toBSON();
    }
    for (var _i5 = 0, _Object$keys = Object.keys(object); _i5 < _Object$keys.length; _i5++) {
      var key = _Object$keys[_i5];
      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
    }
  }
  return totalLength;
}
function calculateElement(name, value) {
  var _value;
  var serializeFunctions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var ignoreUndefined = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  if (typeof ((_value = value) === null || _value === void 0 ? void 0 : _value.toBSON) === 'function') {
    value = value.toBSON();
  }
  switch (_typeof(value)) {
    case 'string':
      return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
    case 'number':
      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      } else {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      }
    case 'undefined':
      if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
      return 0;
    case 'boolean':
      return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
    case 'object':
      if (value != null && typeof value._bsontype === 'string' && value[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
      } else if (value._bsontype === 'ObjectId') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
      } else if (value instanceof Date || isDate(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
      } else if (value._bsontype === 'Long' || value._bsontype === 'Double' || value._bsontype === 'Timestamp') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      } else if (value._bsontype === 'Decimal128') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
      } else if (value._bsontype === 'Code') {
        if (value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
        }
      } else if (value._bsontype === 'Binary') {
        var binary = value;
        if (binary.sub_type === _Binary2.SUBTYPE_BYTE_ARRAY) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
        }
      } else if (value._bsontype === 'Symbol') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
      } else if (value._bsontype === 'DBRef') {
        var ordered_values = Object.assign({
          $ref: value.collection,
          $id: value.oid
        }, value.fields);
        if (value.db != null) {
          ordered_values['$db'] = value.db;
        }
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
      } else if (value instanceof RegExp || isRegExp(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
      } else if (value._bsontype === 'BSONRegExp') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
      } else {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
      }
    case 'function':
      if (serializeFunctions) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
      }
  }
  return 0;
}
function alphabetize(str) {
  return str.split('').sort().join('');
}
var _BSONRegExp = /*#__PURE__*/function (_BSONValue11, _Symbol$for13) {
  _inherits(BSONRegExp, _BSONValue11);
  var _super16 = _createSuper(BSONRegExp);
  function BSONRegExp(pattern, options) {
    var _this10;
    _classCallCheck(this, BSONRegExp);
    _this10 = _super16.call(this);
    _this10.pattern = pattern;
    _this10.options = alphabetize(options !== null && options !== void 0 ? options : '');
    if (_this10.pattern.indexOf('\x00') !== -1) {
      throw new BSONError("BSON Regex patterns cannot contain null bytes, found: ".concat(JSON.stringify(_this10.pattern)));
    }
    if (_this10.options.indexOf('\x00') !== -1) {
      throw new BSONError("BSON Regex options cannot contain null bytes, found: ".concat(JSON.stringify(_this10.options)));
    }
    for (var i = 0; i < _this10.options.length; i++) {
      if (!(_this10.options[i] === 'i' || _this10.options[i] === 'm' || _this10.options[i] === 'x' || _this10.options[i] === 'l' || _this10.options[i] === 's' || _this10.options[i] === 'u')) {
        throw new BSONError("The regular expression option [".concat(_this10.options[i], "] is not supported"));
      }
    }
    return _this10;
  }
  _createClass(BSONRegExp, [{
    key: "_bsontype",
    get: function get() {
      return 'BSONRegExp';
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return {
          $regex: this.pattern,
          $options: this.options
        };
      }
      return {
        $regularExpression: {
          pattern: this.pattern,
          options: this.options
        }
      };
    }
  }, {
    key: _Symbol$for13,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new BSONRegExp(".concat(JSON.stringify(this.pattern), ", ").concat(JSON.stringify(this.options), ")");
    }
  }], [{
    key: "parseOptions",
    value: function parseOptions(options) {
      return options ? options.split('').sort().join('') : '';
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      if ('$regex' in doc) {
        if (typeof doc.$regex !== 'string') {
          if (doc.$regex._bsontype === 'BSONRegExp') {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ('$regularExpression' in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError("Unexpected BSONRegExp EJSON object form: ".concat(JSON.stringify(doc)));
    }
  }]);
  return BSONRegExp;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.BSONRegExp = _BSONRegExp;
var _BSONSymbol = /*#__PURE__*/function (_BSONValue12, _Symbol$for14) {
  _inherits(BSONSymbol, _BSONValue12);
  var _super17 = _createSuper(BSONSymbol);
  function BSONSymbol(value) {
    var _this11;
    _classCallCheck(this, BSONSymbol);
    _this11 = _super17.call(this);
    _this11.value = value;
    return _this11;
  }
  _createClass(BSONSymbol, [{
    key: "_bsontype",
    get: function get() {
      return 'BSONSymbol';
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.value;
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new BSONSymbol(\"".concat(this.value, "\")");
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $symbol: this.value
      };
    }
  }, {
    key: _Symbol$for14,
    value: function value() {
      return this.inspect();
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
  }]);
  return BSONSymbol;
}(BSONValue, Symbol["for"]('nodejs.util.inspect.custom'));
exports.BSONSymbol = _BSONSymbol;
var LongWithoutOverridesClass = _Long;
var _Timestamp = /*#__PURE__*/function (_LongWithoutOverrides, _Symbol$for15) {
  _inherits(Timestamp, _LongWithoutOverrides);
  var _super18 = _createSuper(Timestamp);
  function Timestamp(low) {
    var _this12;
    _classCallCheck(this, Timestamp);
    if (low == null) {
      _this12 = _super18.call(this, 0, 0, true);
    } else if (typeof low === 'bigint') {
      _this12 = _super18.call(this, low, true);
    } else if (_Long.isLong(low)) {
      _this12 = _super18.call(this, low.low, low.high, true);
    } else if (_typeof(low) === 'object' && 't' in low && 'i' in low) {
      if (typeof low.t !== 'number' && (_typeof(low.t) !== 'object' || low.t._bsontype !== 'Int32')) {
        throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');
      }
      if (typeof low.i !== 'number' && (_typeof(low.i) !== 'object' || low.i._bsontype !== 'Int32')) {
        throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');
      }
      if (low.t < 0) {
        throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');
      }
      if (low.i < 0) {
        throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');
      }
      if (low.t > 4294967295) {
        throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');
      }
      if (low.i > 4294967295) {
        throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');
      }
      _this12 = _super18.call(this, low.i.valueOf(), low.t.valueOf(), true);
    } else {
      throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');
    }
    return _possibleConstructorReturn(_this12);
  }
  _createClass(Timestamp, [{
    key: "_bsontype",
    get: function get() {
      return 'Timestamp';
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $timestamp: {
          t: this.high >>> 0,
          i: this.low >>> 0
        }
      };
    }
  }, {
    key: _Symbol$for15,
    value: function value() {
      return this.inspect();
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return "new Timestamp({ t: ".concat(this.getHighBits(), ", i: ").concat(this.getLowBits(), " })");
    }
  }], [{
    key: "fromInt",
    value: function fromInt(value) {
      return new Timestamp(_Long.fromInt(value, true));
    }
  }, {
    key: "fromNumber",
    value: function fromNumber(value) {
      return new Timestamp(_Long.fromNumber(value, true));
    }
  }, {
    key: "fromBits",
    value: function fromBits(lowBits, highBits) {
      return new Timestamp({
        i: lowBits,
        t: highBits
      });
    }
  }, {
    key: "fromString",
    value: function fromString(str, optRadix) {
      return new Timestamp(_Long.fromString(str, true, optRadix));
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      var i = _Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      var t = _Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({
        t: t,
        i: i
      });
    }
  }]);
  return Timestamp;
}(LongWithoutOverridesClass, Symbol["for"]('nodejs.util.inspect.custom'));
exports.Timestamp = _Timestamp;
_Timestamp.MAX_VALUE = _Long.MAX_UNSIGNED_VALUE;
var FIRST_BIT = 0x80;
var FIRST_TWO_BITS = 0xc0;
var FIRST_THREE_BITS = 0xe0;
var FIRST_FOUR_BITS = 0xf0;
var FIRST_FIVE_BITS = 0xf8;
var TWO_BIT_CHAR = 0xc0;
var THREE_BIT_CHAR = 0xe0;
var FOUR_BIT_CHAR = 0xf0;
var CONTINUING_CHAR = 0x80;
function validateUtf8(bytes, start, end) {
  var continuation = 0;
  for (var i = start; i < end; i += 1) {
    var _byte2 = bytes[i];
    if (continuation) {
      if ((_byte2 & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
        return false;
      }
      continuation -= 1;
    } else if (_byte2 & FIRST_BIT) {
      if ((_byte2 & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
        continuation = 1;
      } else if ((_byte2 & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
        continuation = 2;
      } else if ((_byte2 & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
        continuation = 3;
      } else {
        return false;
      }
    }
  }
  return !continuation;
}
var JS_INT_MAX_LONG = _Long.fromNumber(JS_INT_MAX);
var JS_INT_MIN_LONG = _Long.fromNumber(JS_INT_MIN);
function internalDeserialize(buffer, options, isArray) {
  options = options == null ? {} : options;
  var index = options && options.index ? options.index : 0;
  var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
  if (size < 5) {
    throw new BSONError("bson size must be >= 5, is ".concat(size));
  }
  if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
    throw new BSONError("buffer length ".concat(buffer.length, " must be >= bson size ").concat(size));
  }
  if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
    throw new BSONError("buffer length ".concat(buffer.length, " must === bson size ").concat(size));
  }
  if (size + index > buffer.byteLength) {
    throw new BSONError("(bson size ".concat(size, " + options.index ").concat(index, " must be <= buffer length ").concat(buffer.byteLength, ")"));
  }
  if (buffer[index + size - 1] !== 0) {
    throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
  }
  return deserializeObject(buffer, index, options, isArray);
}
var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
function deserializeObject(buffer, index, options) {
  var _options$promoteBuffe, _options$promoteLongs, _options$promoteValue, _options$useBigInt2;
  var isArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
  var raw = options['raw'] == null ? false : options['raw'];
  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;
  var promoteBuffers = (_options$promoteBuffe = options.promoteBuffers) !== null && _options$promoteBuffe !== void 0 ? _options$promoteBuffe : false;
  var promoteLongs = (_options$promoteLongs = options.promoteLongs) !== null && _options$promoteLongs !== void 0 ? _options$promoteLongs : true;
  var promoteValues = (_options$promoteValue = options.promoteValues) !== null && _options$promoteValue !== void 0 ? _options$promoteValue : true;
  var useBigInt64 = (_options$useBigInt2 = options.useBigInt64) !== null && _options$useBigInt2 !== void 0 ? _options$useBigInt2 : false;
  if (useBigInt64 && !promoteValues) {
    throw new BSONError('Must either request bigint or Long for int64 deserialization');
  }
  if (useBigInt64 && !promoteLongs) {
    throw new BSONError('Must either request bigint or Long for int64 deserialization');
  }
  var validation = options.validation == null ? {
    utf8: true
  } : options.validation;
  var globalUTFValidation = true;
  var validationSetting;
  var utf8KeysSet = new Set();
  var utf8ValidatedKeys = validation.utf8;
  if (typeof utf8ValidatedKeys === 'boolean') {
    validationSetting = utf8ValidatedKeys;
  } else {
    globalUTFValidation = false;
    var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {
      return utf8ValidatedKeys[key];
    });
    if (utf8ValidationValues.length === 0) {
      throw new BSONError('UTF-8 validation setting cannot be empty');
    }
    if (typeof utf8ValidationValues[0] !== 'boolean') {
      throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');
    }
    validationSetting = utf8ValidationValues[0];
    if (!utf8ValidationValues.every(function (item) {
      return item === validationSetting;
    })) {
      throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');
    }
  }
  if (!globalUTFValidation) {
    for (var _i6 = 0, _Object$keys2 = Object.keys(utf8ValidatedKeys); _i6 < _Object$keys2.length; _i6++) {
      var key = _Object$keys2[_i6];
      utf8KeysSet.add(key);
    }
  }
  var startIndex = index;
  if (buffer.length < 5) throw new BSONError('corrupt bson message < 5 bytes long');
  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
  if (size < 5 || size > buffer.length) throw new BSONError('corrupt bson message');
  var object = isArray ? [] : {};
  var arrayIndex = 0;
  var done = false;
  var isPossibleDBRef = isArray ? false : null;
  var dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  while (!done) {
    var elementType = buffer[index++];
    if (elementType === 0) break;
    var i = index;
    while (buffer[i] !== 0x00 && i < buffer.length) {
      i++;
    }
    if (i >= buffer.byteLength) throw new BSONError('Bad BSON Document: illegal CString');
    var name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer.subarray(index, i));
    var shouldValidateKey = true;
    if (globalUTFValidation || utf8KeysSet.has(name)) {
      shouldValidateKey = validationSetting;
    } else {
      shouldValidateKey = !validationSetting;
    }
    if (isPossibleDBRef !== false && name[0] === '$') {
      isPossibleDBRef = allowedDBRefKeys.test(name);
    }
    var value = void 0;
    index = i + 1;
    if (elementType === BSON_DATA_STRING) {
      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_OID) {
      var oid = ByteUtils.allocate(12);
      oid.set(buffer.subarray(index, index + 12));
      value = new _ObjectId(oid);
      index = index + 12;
    } else if (elementType === BSON_DATA_INT && promoteValues === false) {
      value = new _Int(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
    } else if (elementType === BSON_DATA_INT) {
      value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
    } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {
      value = new _Double(dataview.getFloat64(index, true));
      index = index + 8;
    } else if (elementType === BSON_DATA_NUMBER) {
      value = dataview.getFloat64(index, true);
      index = index + 8;
    } else if (elementType === BSON_DATA_DATE) {
      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      value = new Date(new _Long(lowBits, highBits).toNumber());
    } else if (elementType === BSON_DATA_BOOLEAN) {
      if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError('illegal boolean type value');
      value = buffer[index++] === 1;
    } else if (elementType === BSON_DATA_OBJECT) {
      var _index = index;
      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError('bad embedded document length in bson');
      if (raw) {
        value = buffer.slice(index, index + objectSize);
      } else {
        var objectOptions = options;
        if (!globalUTFValidation) {
          objectOptions = _objectSpread(_objectSpread({}, options), {}, {
            validation: {
              utf8: shouldValidateKey
            }
          });
        }
        value = deserializeObject(buffer, _index, objectOptions, false);
      }
      index = index + objectSize;
    } else if (elementType === BSON_DATA_ARRAY) {
      var _index2 = index;
      var _objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      var arrayOptions = options;
      var stopIndex = index + _objectSize;
      if (fieldsAsRaw && fieldsAsRaw[name]) {
        arrayOptions = _objectSpread(_objectSpread({}, options), {}, {
          raw: true
        });
      }
      if (!globalUTFValidation) {
        arrayOptions = _objectSpread(_objectSpread({}, arrayOptions), {}, {
          validation: {
            utf8: shouldValidateKey
          }
        });
      }
      value = deserializeObject(buffer, _index2, arrayOptions, true);
      index = index + _objectSize;
      if (buffer[index - 1] !== 0) throw new BSONError('invalid array terminator byte');
      if (index !== stopIndex) throw new BSONError('corrupted array bson');
    } else if (elementType === BSON_DATA_UNDEFINED) {
      value = undefined;
    } else if (elementType === BSON_DATA_NULL) {
      value = null;
    } else if (elementType === BSON_DATA_LONG) {
      var _dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));
      var _lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var _highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var _long = new _Long(_lowBits, _highBits);
      if (useBigInt64) {
        value = _dataview.getBigInt64(0, true);
      } else if (promoteLongs && promoteValues === true) {
        value = _long.lessThanOrEqual(JS_INT_MAX_LONG) && _long.greaterThanOrEqual(JS_INT_MIN_LONG) ? _long.toNumber() : _long;
      } else {
        value = _long;
      }
    } else if (elementType === BSON_DATA_DECIMAL128) {
      var bytes = ByteUtils.allocate(16);
      bytes.set(buffer.subarray(index, index + 16), 0);
      index = index + 16;
      value = new _Decimal(bytes);
    } else if (elementType === BSON_DATA_BINARY) {
      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var totalBinarySize = binarySize;
      var subType = buffer[index++];
      if (binarySize < 0) throw new BSONError('Negative binary type element size found');
      if (binarySize > buffer.byteLength) throw new BSONError('Binary type size larger than document size');
      if (buffer['slice'] != null) {
        if (subType === _Binary2.SUBTYPE_BYTE_ARRAY) {
          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02');
          if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size');
          if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size');
        }
        if (promoteBuffers && promoteValues) {
          value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));
        } else {
          value = new _Binary2(buffer.slice(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {
            value = value.toUUID();
          }
        }
      } else {
        var _buffer = ByteUtils.allocate(binarySize);
        if (subType === _Binary2.SUBTYPE_BYTE_ARRAY) {
          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02');
          if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size');
          if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size');
        }
        for (i = 0; i < binarySize; i++) {
          _buffer[i] = buffer[index + i];
        }
        if (promoteBuffers && promoteValues) {
          value = _buffer;
        } else if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {
          value = new _Binary2(buffer.slice(index, index + binarySize), subType).toUUID();
        } else {
          value = new _Binary2(buffer.slice(index, index + binarySize), subType);
        }
      }
      index = index + binarySize;
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var source = ByteUtils.toUTF8(buffer.subarray(index, i));
      index = i + 1;
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var regExpOptions = ByteUtils.toUTF8(buffer.subarray(index, i));
      index = i + 1;
      var optionsArray = new Array(regExpOptions.length);
      for (i = 0; i < regExpOptions.length; i++) {
        switch (regExpOptions[i]) {
          case 'm':
            optionsArray[i] = 'm';
            break;
          case 's':
            optionsArray[i] = 'g';
            break;
          case 'i':
            optionsArray[i] = 'i';
            break;
        }
      }
      value = new RegExp(source, optionsArray.join(''));
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var _source = ByteUtils.toUTF8(buffer.subarray(index, i));
      index = i + 1;
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var _regExpOptions = ByteUtils.toUTF8(buffer.subarray(index, i));
      index = i + 1;
      value = new _BSONRegExp(_source, _regExpOptions);
    } else if (elementType === BSON_DATA_SYMBOL) {
      var _stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (_stringSize <= 0 || _stringSize > buffer.length - index || buffer[index + _stringSize - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      var symbol = getValidatedString(buffer, index, index + _stringSize - 1, shouldValidateKey);
      value = promoteValues ? symbol : new _BSONSymbol(symbol);
      index = index + _stringSize;
    } else if (elementType === BSON_DATA_TIMESTAMP) {
      var _i7 = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);
      var t = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);
      value = new _Timestamp({
        i: _i7,
        t: t
      });
    } else if (elementType === BSON_DATA_MIN_KEY) {
      value = new _MinKey();
    } else if (elementType === BSON_DATA_MAX_KEY) {
      value = new _MaxKey();
    } else if (elementType === BSON_DATA_CODE) {
      var _stringSize2 = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (_stringSize2 <= 0 || _stringSize2 > buffer.length - index || buffer[index + _stringSize2 - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      var functionString = getValidatedString(buffer, index, index + _stringSize2 - 1, shouldValidateKey);
      value = new _Code(functionString);
      index = index + _stringSize2;
    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (totalSize < 4 + 4 + 4 + 1) {
        throw new BSONError('code_w_scope total size shorter minimum expected length');
      }
      var _stringSize3 = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (_stringSize3 <= 0 || _stringSize3 > buffer.length - index || buffer[index + _stringSize3 - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      var _functionString = getValidatedString(buffer, index, index + _stringSize3 - 1, shouldValidateKey);
      index = index + _stringSize3;
      var _index3 = index;
      var _objectSize2 = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      var scopeObject = deserializeObject(buffer, _index3, options, false);
      index = index + _objectSize2;
      if (totalSize < 4 + 4 + _objectSize2 + _stringSize3) {
        throw new BSONError('code_w_scope total size is too short, truncating scope');
      }
      if (totalSize > 4 + 4 + _objectSize2 + _stringSize3) {
        throw new BSONError('code_w_scope total size is too long, clips outer document');
      }
      value = new _Code(_functionString, scopeObject);
    } else if (elementType === BSON_DATA_DBPOINTER) {
      var _stringSize4 = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (_stringSize4 <= 0 || _stringSize4 > buffer.length - index || buffer[index + _stringSize4 - 1] !== 0) throw new BSONError('bad string length in bson');
      if (validation != null && validation.utf8) {
        if (!validateUtf8(buffer, index, index + _stringSize4 - 1)) {
          throw new BSONError('Invalid UTF-8 string in BSON document');
        }
      }
      var namespace = ByteUtils.toUTF8(buffer.subarray(index, index + _stringSize4 - 1));
      index = index + _stringSize4;
      var oidBuffer = ByteUtils.allocate(12);
      oidBuffer.set(buffer.subarray(index, index + 12), 0);
      var _oid = new _ObjectId(oidBuffer);
      index = index + 12;
      value = new _DBRef(namespace, _oid);
    } else {
      throw new BSONError("Detected unknown BSON type ".concat(elementType.toString(16), " for fieldname \"").concat(name, "\""));
    }
    if (name === '__proto__') {
      Object.defineProperty(object, name, {
        value: value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } else {
      object[name] = value;
    }
  }
  if (size !== index - startIndex) {
    if (isArray) throw new BSONError('corrupt array bson');
    throw new BSONError('corrupt object bson');
  }
  if (!isPossibleDBRef) return object;
  if (isDBRefLike(object)) {
    var copy = Object.assign({}, object);
    delete copy.$ref;
    delete copy.$id;
    delete copy.$db;
    return new _DBRef(object.$ref, object.$id, object.$db, copy);
  }
  return object;
}
function getValidatedString(buffer, start, end, shouldValidateUtf8) {
  var value = ByteUtils.toUTF8(buffer.subarray(start, end));
  if (shouldValidateUtf8) {
    for (var i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) === 0xfffd) {
        if (!validateUtf8(buffer, start, end)) {
          throw new BSONError('Invalid UTF-8 string in BSON document');
        }
        break;
      }
    }
  }
  return value;
}
var regexp = /\x00/;
var ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);
function serializeString(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_STRING;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes + 1;
  buffer[index - 1] = 0;
  var size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);
  buffer[index + 3] = size + 1 >> 24 & 0xff;
  buffer[index + 2] = size + 1 >> 16 & 0xff;
  buffer[index + 1] = size + 1 >> 8 & 0xff;
  buffer[index] = size + 1 & 0xff;
  index = index + 4 + size;
  buffer[index++] = 0;
  return index;
}
var NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);
var FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);
var EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);
function serializeNumber(buffer, key, value, index) {
  var isNegativeZero = Object.is(value, -0);
  var type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
  if (type === BSON_DATA_INT) {
    NUMBER_SPACE.setInt32(0, value, true);
  } else {
    NUMBER_SPACE.setFloat64(0, value, true);
  }
  var bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;
  buffer[index++] = type;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0x00;
  buffer.set(bytes, index);
  index += bytes.byteLength;
  return index;
}
function serializeBigInt(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_LONG;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index += numberOfWrittenBytes;
  buffer[index++] = 0;
  NUMBER_SPACE.setBigInt64(0, value, true);
  buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
  index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;
  return index;
}
function serializeNull(buffer, key, _, index) {
  buffer[index++] = BSON_DATA_NULL;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}
function serializeBoolean(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_BOOLEAN;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  buffer[index++] = value ? 1 : 0;
  return index;
}
function serializeDate(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_DATE;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var dateInMilis = _Long.fromNumber(value.getTime());
  var lowBits = dateInMilis.getLowBits();
  var highBits = dateInMilis.getHighBits();
  buffer[index++] = lowBits & 0xff;
  buffer[index++] = lowBits >> 8 & 0xff;
  buffer[index++] = lowBits >> 16 & 0xff;
  buffer[index++] = lowBits >> 24 & 0xff;
  buffer[index++] = highBits & 0xff;
  buffer[index++] = highBits >> 8 & 0xff;
  buffer[index++] = highBits >> 16 & 0xff;
  buffer[index++] = highBits >> 24 & 0xff;
  return index;
}
function serializeRegExp(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_REGEXP;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.source && value.source.match(regexp) != null) {
    throw new BSONError('value ' + value.source + ' must not contain null bytes');
  }
  index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);
  buffer[index++] = 0x00;
  if (value.ignoreCase) buffer[index++] = 0x69;
  if (value.global) buffer[index++] = 0x73;
  if (value.multiline) buffer[index++] = 0x6d;
  buffer[index++] = 0x00;
  return index;
}
function serializeBSONRegExp(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_REGEXP;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.pattern.match(regexp) != null) {
    throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');
  }
  index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);
  buffer[index++] = 0x00;
  var sortedOptions = value.options.split('').sort().join('');
  index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);
  buffer[index++] = 0x00;
  return index;
}
function serializeMinMax(buffer, key, value, index) {
  if (value === null) {
    buffer[index++] = BSON_DATA_NULL;
  } else if (value._bsontype === 'MinKey') {
    buffer[index++] = BSON_DATA_MIN_KEY;
  } else {
    buffer[index++] = BSON_DATA_MAX_KEY;
  }
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}
function serializeObjectId(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_OID;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (isUint8Array(value.id)) {
    buffer.set(value.id.subarray(0, 12), index);
  } else {
    throw new BSONError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');
  }
  return index + 12;
}
function serializeBuffer(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_BINARY;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var size = value.length;
  buffer[index++] = size & 0xff;
  buffer[index++] = size >> 8 & 0xff;
  buffer[index++] = size >> 16 & 0xff;
  buffer[index++] = size >> 24 & 0xff;
  buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
  buffer.set(value, index);
  index = index + size;
  return index;
}
function serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
  if (path.has(value)) {
    throw new BSONError('Cannot convert circular structure to BSON');
  }
  path.add(value);
  buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
  path["delete"](value);
  return endIndex;
}
function serializeDecimal128(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_DECIMAL128;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  buffer.set(value.bytes.subarray(0, 16), index);
  return index + 16;
}
function serializeLong(buffer, key, value, index) {
  buffer[index++] = value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var lowBits = value.getLowBits();
  var highBits = value.getHighBits();
  buffer[index++] = lowBits & 0xff;
  buffer[index++] = lowBits >> 8 & 0xff;
  buffer[index++] = lowBits >> 16 & 0xff;
  buffer[index++] = lowBits >> 24 & 0xff;
  buffer[index++] = highBits & 0xff;
  buffer[index++] = highBits >> 8 & 0xff;
  buffer[index++] = highBits >> 16 & 0xff;
  buffer[index++] = highBits >> 24 & 0xff;
  return index;
}
function serializeInt32(buffer, key, value, index) {
  value = value.valueOf();
  buffer[index++] = BSON_DATA_INT;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  buffer[index++] = value & 0xff;
  buffer[index++] = value >> 8 & 0xff;
  buffer[index++] = value >> 16 & 0xff;
  buffer[index++] = value >> 24 & 0xff;
  return index;
}
function serializeDouble(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_NUMBER;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  NUMBER_SPACE.setFloat64(0, value.value, true);
  buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
  index = index + 8;
  return index;
}
function serializeFunction(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_CODE;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var functionString = value.toString();
  var size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
  buffer[index] = size & 0xff;
  buffer[index + 1] = size >> 8 & 0xff;
  buffer[index + 2] = size >> 16 & 0xff;
  buffer[index + 3] = size >> 24 & 0xff;
  index = index + 4 + size - 1;
  buffer[index++] = 0;
  return index;
}
function serializeCode(buffer, key, value, index) {
  var checkKeys = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var depth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var serializeFunctions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var ignoreUndefined = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
  var path = arguments.length > 8 ? arguments[8] : undefined;
  if (value.scope && _typeof(value.scope) === 'object') {
    buffer[index++] = BSON_DATA_CODE_W_SCOPE;
    var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var startIndex = index;
    var functionString = value.code;
    index = index + 4;
    var codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
    buffer[index] = codeSize & 0xff;
    buffer[index + 1] = codeSize >> 8 & 0xff;
    buffer[index + 2] = codeSize >> 16 & 0xff;
    buffer[index + 3] = codeSize >> 24 & 0xff;
    buffer[index + 4 + codeSize - 1] = 0;
    index = index + codeSize + 4;
    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    index = endIndex - 1;
    var totalSize = endIndex - startIndex;
    buffer[startIndex++] = totalSize & 0xff;
    buffer[startIndex++] = totalSize >> 8 & 0xff;
    buffer[startIndex++] = totalSize >> 16 & 0xff;
    buffer[startIndex++] = totalSize >> 24 & 0xff;
    buffer[index++] = 0;
  } else {
    buffer[index++] = BSON_DATA_CODE;
    var _numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
    index = index + _numberOfWrittenBytes;
    buffer[index++] = 0;
    var _functionString2 = value.code.toString();
    var size = ByteUtils.encodeUTF8Into(buffer, _functionString2, index + 4) + 1;
    buffer[index] = size & 0xff;
    buffer[index + 1] = size >> 8 & 0xff;
    buffer[index + 2] = size >> 16 & 0xff;
    buffer[index + 3] = size >> 24 & 0xff;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
  }
  return index;
}
function serializeBinary(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_BINARY;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var data = value.buffer;
  var size = value.position;
  if (value.sub_type === _Binary2.SUBTYPE_BYTE_ARRAY) size = size + 4;
  buffer[index++] = size & 0xff;
  buffer[index++] = size >> 8 & 0xff;
  buffer[index++] = size >> 16 & 0xff;
  buffer[index++] = size >> 24 & 0xff;
  buffer[index++] = value.sub_type;
  if (value.sub_type === _Binary2.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    buffer[index++] = size & 0xff;
    buffer[index++] = size >> 8 & 0xff;
    buffer[index++] = size >> 16 & 0xff;
    buffer[index++] = size >> 24 & 0xff;
  }
  buffer.set(data, index);
  index = index + value.position;
  return index;
}
function serializeSymbol(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_SYMBOL;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;
  buffer[index] = size & 0xff;
  buffer[index + 1] = size >> 8 & 0xff;
  buffer[index + 2] = size >> 16 & 0xff;
  buffer[index + 3] = size >> 24 & 0xff;
  index = index + 4 + size - 1;
  buffer[index++] = 0x00;
  return index;
}
function serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {
  buffer[index++] = BSON_DATA_OBJECT;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var startIndex = index;
  var output = {
    $ref: value.collection || value.namespace,
    $id: value.oid
  };
  if (value.db != null) {
    output.$db = value.db;
  }
  output = Object.assign(output, value.fields);
  var endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);
  var size = endIndex - startIndex;
  buffer[startIndex++] = size & 0xff;
  buffer[startIndex++] = size >> 8 & 0xff;
  buffer[startIndex++] = size >> 16 & 0xff;
  buffer[startIndex++] = size >> 24 & 0xff;
  return endIndex;
}
function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
  if (path == null) {
    if (object == null) {
      buffer[0] = 0x05;
      buffer[1] = 0x00;
      buffer[2] = 0x00;
      buffer[3] = 0x00;
      buffer[4] = 0x00;
      return 5;
    }
    if (Array.isArray(object)) {
      throw new BSONError('serialize does not support an array as the root input');
    }
    if (_typeof(object) !== 'object') {
      throw new BSONError('serialize does not support non-object as the root input');
    } else if ('_bsontype' in object && typeof object._bsontype === 'string') {
      throw new BSONError("BSON types cannot be serialized as a document");
    } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
      throw new BSONError("date, regexp, typedarray, and arraybuffer cannot be BSON documents");
    }
    path = new Set();
  }
  path.add(object);
  var index = startingIndex + 4;
  if (Array.isArray(object)) {
    for (var i = 0; i < object.length; i++) {
      var _value2;
      var key = "".concat(i);
      var value = object[i];
      if (typeof ((_value2 = value) === null || _value2 === void 0 ? void 0 : _value2.toBSON) === 'function') {
        value = value.toBSON();
      }
      if (typeof value === 'string') {
        index = serializeString(buffer, key, value, index);
      } else if (typeof value === 'number') {
        index = serializeNumber(buffer, key, value, index);
      } else if (typeof value === 'bigint') {
        index = serializeBigInt(buffer, key, value, index);
      } else if (typeof value === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === undefined) {
        index = serializeNull(buffer, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if (_typeof(value) === 'object' && value._bsontype == null) {
        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (_typeof(value) === 'object' && value[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (value._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (value._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value._bsontype === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index);
      } else if (value._bsontype === 'Code') {
        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (value._bsontype === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
      } else if (value._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value._bsontype === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value._bsontype !== 'undefined') {
        throw new BSONError("Unrecognized or invalid _bsontype: ".concat(String(value._bsontype)));
      }
    }
  } else if (object instanceof Map || isMap(object)) {
    var iterator = object.entries();
    var done = false;
    while (!done) {
      var _value4;
      var entry = iterator.next();
      done = !!entry.done;
      if (done) continue;
      var _key = entry.value[0];
      var _value3 = entry.value[1];
      if (typeof ((_value4 = _value3) === null || _value4 === void 0 ? void 0 : _value4.toBSON) === 'function') {
        _value3 = _value3.toBSON();
      }
      var type = _typeof(_value3);
      if (typeof _key === 'string' && !ignoreKeys.has(_key)) {
        if (_key.match(regexp) != null) {
          throw new BSONError('key ' + _key + ' must not contain null bytes');
        }
        if (checkKeys) {
          if ('$' === _key[0]) {
            throw new BSONError('key ' + _key + " must not start with '$'");
          } else if (~_key.indexOf('.')) {
            throw new BSONError('key ' + _key + " must not contain '.'");
          }
        }
      }
      if (type === 'string') {
        index = serializeString(buffer, _key, _value3, index);
      } else if (type === 'number') {
        index = serializeNumber(buffer, _key, _value3, index);
      } else if (type === 'bigint') {
        index = serializeBigInt(buffer, _key, _value3, index);
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, _key, _value3, index);
      } else if (_value3 instanceof Date || isDate(_value3)) {
        index = serializeDate(buffer, _key, _value3, index);
      } else if (_value3 === null || _value3 === undefined && ignoreUndefined === false) {
        index = serializeNull(buffer, _key, _value3, index);
      } else if (isUint8Array(_value3)) {
        index = serializeBuffer(buffer, _key, _value3, index);
      } else if (_value3 instanceof RegExp || isRegExp(_value3)) {
        index = serializeRegExp(buffer, _key, _value3, index);
      } else if (type === 'object' && _value3._bsontype == null) {
        index = serializeObject(buffer, _key, _value3, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (_typeof(_value3) === 'object' && _value3[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (_value3._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, _key, _value3, index);
      } else if (type === 'object' && _value3._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Long' || _value3._bsontype === 'Timestamp') {
        index = serializeLong(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Double') {
        index = serializeDouble(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Code') {
        index = serializeCode(buffer, _key, _value3, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (typeof _value3 === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Binary') {
        index = serializeBinary(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, _key, _value3, index, depth, serializeFunctions, path);
      } else if (_value3._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Int32') {
        index = serializeInt32(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'MinKey' || _value3._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, _key, _value3, index);
      } else if (typeof _value3._bsontype !== 'undefined') {
        throw new BSONError("Unrecognized or invalid _bsontype: ".concat(String(_value3._bsontype)));
      }
    }
  } else {
    var _object2;
    if (typeof ((_object2 = object) === null || _object2 === void 0 ? void 0 : _object2.toBSON) === 'function') {
      object = object.toBSON();
      if (object != null && _typeof(object) !== 'object') {
        throw new BSONError('toBSON function did not return an object');
      }
    }
    for (var _i8 = 0, _Object$keys3 = Object.keys(object); _i8 < _Object$keys3.length; _i8++) {
      var _value6;
      var _key2 = _Object$keys3[_i8];
      var _value5 = object[_key2];
      if (typeof ((_value6 = _value5) === null || _value6 === void 0 ? void 0 : _value6.toBSON) === 'function') {
        _value5 = _value5.toBSON();
      }
      var _type = _typeof(_value5);
      if (typeof _key2 === 'string' && !ignoreKeys.has(_key2)) {
        if (_key2.match(regexp) != null) {
          throw new BSONError('key ' + _key2 + ' must not contain null bytes');
        }
        if (checkKeys) {
          if ('$' === _key2[0]) {
            throw new BSONError('key ' + _key2 + " must not start with '$'");
          } else if (~_key2.indexOf('.')) {
            throw new BSONError('key ' + _key2 + " must not contain '.'");
          }
        }
      }
      if (_type === 'string') {
        index = serializeString(buffer, _key2, _value5, index);
      } else if (_type === 'number') {
        index = serializeNumber(buffer, _key2, _value5, index);
      } else if (_type === 'bigint') {
        index = serializeBigInt(buffer, _key2, _value5, index);
      } else if (_type === 'boolean') {
        index = serializeBoolean(buffer, _key2, _value5, index);
      } else if (_value5 instanceof Date || isDate(_value5)) {
        index = serializeDate(buffer, _key2, _value5, index);
      } else if (_value5 === undefined) {
        if (ignoreUndefined === false) index = serializeNull(buffer, _key2, _value5, index);
      } else if (_value5 === null) {
        index = serializeNull(buffer, _key2, _value5, index);
      } else if (isUint8Array(_value5)) {
        index = serializeBuffer(buffer, _key2, _value5, index);
      } else if (_value5 instanceof RegExp || isRegExp(_value5)) {
        index = serializeRegExp(buffer, _key2, _value5, index);
      } else if (_type === 'object' && _value5._bsontype == null) {
        index = serializeObject(buffer, _key2, _value5, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (_typeof(_value5) === 'object' && _value5[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (_value5._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, _key2, _value5, index);
      } else if (_type === 'object' && _value5._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Long' || _value5._bsontype === 'Timestamp') {
        index = serializeLong(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Double') {
        index = serializeDouble(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Code') {
        index = serializeCode(buffer, _key2, _value5, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (typeof _value5 === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Binary') {
        index = serializeBinary(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, _key2, _value5, index, depth, serializeFunctions, path);
      } else if (_value5._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Int32') {
        index = serializeInt32(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'MinKey' || _value5._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, _key2, _value5, index);
      } else if (typeof _value5._bsontype !== 'undefined') {
        throw new BSONError("Unrecognized or invalid _bsontype: ".concat(String(_value5._bsontype)));
      }
    }
  }
  path["delete"](object);
  buffer[index++] = 0x00;
  var size = index - startingIndex;
  buffer[startingIndex++] = size & 0xff;
  buffer[startingIndex++] = size >> 8 & 0xff;
  buffer[startingIndex++] = size >> 16 & 0xff;
  buffer[startingIndex++] = size >> 24 & 0xff;
  return index;
}
function isBSONType(value) {
  return value != null && _typeof(value) === 'object' && '_bsontype' in value && typeof value._bsontype === 'string';
}
var keysToCodecs = {
  $oid: _ObjectId,
  $binary: _Binary2,
  $uuid: _Binary2,
  $symbol: _BSONSymbol,
  $numberInt: _Int,
  $numberDecimal: _Decimal,
  $numberDouble: _Double,
  $numberLong: _Long,
  $minKey: _MinKey,
  $maxKey: _MaxKey,
  $regex: _BSONRegExp,
  $regularExpression: _BSONRegExp,
  $timestamp: _Timestamp
};
function deserializeValue(value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof value === 'number') {
    var in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
    var in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
    if (options.relaxed || options.legacy) {
      return value;
    }
    if (Number.isInteger(value) && !Object.is(value, -0)) {
      if (in32BitRange) {
        return new _Int(value);
      }
      if (in64BitRange) {
        if (options.useBigInt64) {
          return BigInt(value);
        }
        return _Long.fromNumber(value);
      }
    }
    return new _Double(value);
  }
  if (value == null || _typeof(value) !== 'object') return value;
  if (value.$undefined) return null;
  var keys = Object.keys(value).filter(function (k) {
    return k.startsWith('$') && value[k] != null;
  });
  for (var i = 0; i < keys.length; i++) {
    var c = keysToCodecs[keys[i]];
    if (c) return c.fromExtendedJSON(value, options);
  }
  if (value.$date != null) {
    var d = value.$date;
    var date = new Date();
    if (options.legacy) {
      if (typeof d === 'number') date.setTime(d);else if (typeof d === 'string') date.setTime(Date.parse(d));else if (typeof d === 'bigint') date.setTime(Number(d));else throw new BSONRuntimeError("Unrecognized type for EJSON date: ".concat(_typeof(d)));
    } else {
      if (typeof d === 'string') date.setTime(Date.parse(d));else if (_Long.isLong(d)) date.setTime(d.toNumber());else if (typeof d === 'number' && options.relaxed) date.setTime(d);else if (typeof d === 'bigint') date.setTime(Number(d));else throw new BSONRuntimeError("Unrecognized type for EJSON date: ".concat(_typeof(d)));
    }
    return date;
  }
  if (value.$code != null) {
    var copy = Object.assign({}, value);
    if (value.$scope) {
      copy.$scope = deserializeValue(value.$scope);
    }
    return _Code.fromExtendedJSON(value);
  }
  if (isDBRefLike(value) || value.$dbPointer) {
    var v = value.$ref ? value : value.$dbPointer;
    if (v instanceof _DBRef) return v;
    var dollarKeys = Object.keys(v).filter(function (k) {
      return k.startsWith('$');
    });
    var valid = true;
    dollarKeys.forEach(function (k) {
      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;
    });
    if (valid) return _DBRef.fromExtendedJSON(v);
  }
  return value;
}
function serializeArray(array, options) {
  return array.map(function (v, index) {
    options.seenObjects.push({
      propertyName: "index ".concat(index),
      obj: null
    });
    try {
      return serializeValue(v, options);
    } finally {
      options.seenObjects.pop();
    }
  });
}
function getISOString(date) {
  var isoStr = date.toISOString();
  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';
}
function serializeValue(value, options) {
  if (value instanceof Map || isMap(value)) {
    var obj = Object.create(null);
    var _iterator = _createForOfIteratorHelper(value),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          k = _step$value[0],
          v = _step$value[1];
        if (typeof k !== 'string') {
          throw new BSONError('Can only serialize maps with string keys');
        }
        obj[k] = v;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return serializeValue(obj, options);
  }
  if ((_typeof(value) === 'object' || typeof value === 'function') && value !== null) {
    var index = options.seenObjects.findIndex(function (entry) {
      return entry.obj === value;
    });
    if (index !== -1) {
      var props = options.seenObjects.map(function (entry) {
        return entry.propertyName;
      });
      var leadingPart = props.slice(0, index).map(function (prop) {
        return "".concat(prop, " -> ");
      }).join('');
      var alreadySeen = props[index];
      var circularPart = ' -> ' + props.slice(index + 1, props.length - 1).map(function (prop) {
        return "".concat(prop, " -> ");
      }).join('');
      var current = props[props.length - 1];
      var leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);
      var dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
      throw new BSONError('Converting circular structure to EJSON:\n' + "    ".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, "\n") + "    ".concat(leadingSpace, "\\").concat(dashes, "/"));
    }
    options.seenObjects[options.seenObjects.length - 1].obj = value;
  }
  if (Array.isArray(value)) return serializeArray(value, options);
  if (value === undefined) return null;
  if (value instanceof Date || isDate(value)) {
    var dateNum = value.getTime(),
      inRange = dateNum > -1 && dateNum < 253402318800000;
    if (options.legacy) {
      return options.relaxed && inRange ? {
        $date: value.getTime()
      } : {
        $date: getISOString(value)
      };
    }
    return options.relaxed && inRange ? {
      $date: getISOString(value)
    } : {
      $date: {
        $numberLong: value.getTime().toString()
      }
    };
  }
  if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {
    if (Number.isInteger(value) && !Object.is(value, -0)) {
      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
        return {
          $numberInt: value.toString()
        };
      }
      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
        return {
          $numberLong: value.toString()
        };
      }
    }
    return {
      $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString()
    };
  }
  if (typeof value === 'bigint') {
    if (!options.relaxed) {
      return {
        $numberLong: BigInt.asIntN(64, value).toString()
      };
    }
    return Number(BigInt.asIntN(64, value));
  }
  if (value instanceof RegExp || isRegExp(value)) {
    var flags = value.flags;
    if (flags === undefined) {
      var match = value.toString().match(/[gimuy]*$/);
      if (match) {
        flags = match[0];
      }
    }
    var rx = new _BSONRegExp(value.source, flags);
    return rx.toExtendedJSON(options);
  }
  if (value != null && _typeof(value) === 'object') return serializeDocument(value, options);
  return value;
}
var BSON_TYPE_MAPPINGS = {
  Binary: function Binary(o) {
    return new _Binary2(o.value(), o.sub_type);
  },
  Code: function Code(o) {
    return new _Code(o.code, o.scope);
  },
  DBRef: function DBRef(o) {
    return new _DBRef(o.collection || o.namespace, o.oid, o.db, o.fields);
  },
  Decimal128: function Decimal128(o) {
    return new _Decimal(o.bytes);
  },
  Double: function Double(o) {
    return new _Double(o.value);
  },
  Int32: function Int32(o) {
    return new _Int(o.value);
  },
  Long: function Long(o) {
    return _Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_);
  },
  MaxKey: function MaxKey() {
    return new _MaxKey();
  },
  MinKey: function MinKey() {
    return new _MinKey();
  },
  ObjectId: function ObjectId(o) {
    return new _ObjectId(o);
  },
  BSONRegExp: function BSONRegExp(o) {
    return new _BSONRegExp(o.pattern, o.options);
  },
  BSONSymbol: function BSONSymbol(o) {
    return new _BSONSymbol(o.value);
  },
  Timestamp: function Timestamp(o) {
    return _Timestamp.fromBits(o.low, o.high);
  }
};
function serializeDocument(doc, options) {
  if (doc == null || _typeof(doc) !== 'object') throw new BSONError('not an object instance');
  var bsontype = doc._bsontype;
  if (typeof bsontype === 'undefined') {
    var _doc = {};
    for (var _i9 = 0, _Object$keys4 = Object.keys(doc); _i9 < _Object$keys4.length; _i9++) {
      var name = _Object$keys4[_i9];
      options.seenObjects.push({
        propertyName: name,
        obj: null
      });
      try {
        var value = serializeValue(doc[name], options);
        if (name === '__proto__') {
          Object.defineProperty(_doc, name, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (doc != null && _typeof(doc) === 'object' && typeof doc._bsontype === 'string' && doc[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
    throw new BSONVersionError();
  } else if (isBSONType(doc)) {
    var outDoc = doc;
    if (typeof outDoc.toExtendedJSON !== 'function') {
      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }
    if (bsontype === 'Code' && outDoc.scope) {
      outDoc = new _Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === 'DBRef' && outDoc.oid) {
      outDoc = new _DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
    }
    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError('_bsontype must be a string, but was: ' + _typeof(bsontype));
  }
}
function parse(text, options) {
  var _options$useBigInt3, _options$relaxed2, _options$legacy;
  var ejsonOptions = {
    useBigInt64: (_options$useBigInt3 = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _options$useBigInt3 !== void 0 ? _options$useBigInt3 : false,
    relaxed: (_options$relaxed2 = options === null || options === void 0 ? void 0 : options.relaxed) !== null && _options$relaxed2 !== void 0 ? _options$relaxed2 : true,
    legacy: (_options$legacy = options === null || options === void 0 ? void 0 : options.legacy) !== null && _options$legacy !== void 0 ? _options$legacy : false
  };
  return JSON.parse(text, function (key, value) {
    if (key.indexOf('\x00') !== -1) {
      throw new BSONError("BSON Document field names cannot contain null bytes, found: ".concat(JSON.stringify(key)));
    }
    return deserializeValue(value, ejsonOptions);
  });
}
function stringify(value, replacer, space, options) {
  if (space != null && _typeof(space) === 'object') {
    options = space;
    space = 0;
  }
  if (replacer != null && _typeof(replacer) === 'object' && !Array.isArray(replacer)) {
    options = replacer;
    replacer = undefined;
    space = 0;
  }
  var serializeOptions = Object.assign({
    relaxed: true,
    legacy: false
  }, options, {
    seenObjects: [{
      propertyName: '(root)',
      obj: null
    }]
  });
  var doc = serializeValue(value, serializeOptions);
  return JSON.stringify(doc, replacer, space);
}
function EJSONserialize(value, options) {
  options = options || {};
  return JSON.parse(stringify(value, options));
}
function EJSONdeserialize(ejson, options) {
  options = options || {};
  return parse(JSON.stringify(ejson), options);
}
var EJSON = Object.create(null);
exports.EJSON = EJSON;
EJSON.parse = parse;
EJSON.stringify = stringify;
EJSON.serialize = EJSONserialize;
EJSON.deserialize = EJSONdeserialize;
Object.freeze(EJSON);
var MAXSIZE = 1024 * 1024 * 17;
var buffer = ByteUtils.allocate(MAXSIZE);
function setInternalBufferSize(size) {
  if (buffer.length < size) {
    buffer = ByteUtils.allocate(size);
  }
}
function serialize(object) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  var minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;
  if (buffer.length < minInternalBufferSize) {
    buffer = ByteUtils.allocate(minInternalBufferSize);
  }
  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
  var finishedBuffer = ByteUtils.allocate(serializationIndex);
  finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
  return finishedBuffer;
}
function serializeWithBufferAndIndex(object, finalBuffer) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  var startIndex = typeof options.index === 'number' ? options.index : 0;
  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
  finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
  return startIndex + serializationIndex - 1;
}
function deserialize(buffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);
}
function calculateObjectSize(object) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = options || {};
  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
}
function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  var internalOptions = Object.assign({
    allowObjectSmallerThanBufferSize: true,
    index: 0
  }, options);
  var bufferData = ByteUtils.toLocalBufferType(data);
  var index = startIndex;
  for (var i = 0; i < numberOfDocuments; i++) {
    var size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;
    internalOptions.index = index;
    documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
    index = index + size;
  }
  return index;
}
var bson = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Code: _Code,
  BSONSymbol: _BSONSymbol,
  DBRef: _DBRef,
  Binary: _Binary2,
  ObjectId: _ObjectId,
  UUID: UUID,
  Long: _Long,
  Timestamp: _Timestamp,
  Double: _Double,
  Int32: _Int,
  MinKey: _MinKey,
  MaxKey: _MaxKey,
  BSONRegExp: _BSONRegExp,
  Decimal128: _Decimal,
  setInternalBufferSize: setInternalBufferSize,
  serialize: serialize,
  serializeWithBufferAndIndex: serializeWithBufferAndIndex,
  deserialize: deserialize,
  calculateObjectSize: calculateObjectSize,
  deserializeStream: deserializeStream,
  BSONValue: BSONValue,
  BSONError: BSONError,
  BSONVersionError: BSONVersionError,
  BSONRuntimeError: BSONRuntimeError,
  BSONType: BSONType,
  EJSON: EJSON
});
exports.BSON = bson;