"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformRangeReply = exports.pushSlotRangesArguments = exports.pushSortArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.pushOptionalVerdictArgument = exports.pushVerdictArgument = exports.pushVerdictNumberArguments = exports.pushVerdictArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformGeoMembersWithReply = exports.GeoReplyWith = exports.pushGeoRadiusStoreArguments = exports.pushGeoRadiusArguments = exports.pushGeoSearchArguments = exports.pushGeoCountArgument = exports.transformLMPopArguments = exports.transformZMPopArguments = exports.transformSortedSetWithScoresReply = exports.transformSortedSetMemberReply = exports.transformSortedSetMemberNullReply = exports.transformStreamsMessagesReply = exports.transformStreamMessagesReply = exports.transformTuplesReply = exports.transformStringNumberInfinityArgument = exports.transformNumberInfinityArgument = exports.transformNumberInfinityNullArrayReply = exports.transformNumberInfinityNullReply = exports.transformNumberInfinityReply = exports.pushScanArguments = exports.transformBooleanArrayReply = exports.transformBooleanReply = void 0;
function transformBooleanReply(reply) {
  return reply === 1;
}
exports.transformBooleanReply = transformBooleanReply;
function transformBooleanArrayReply(reply) {
  return reply.map(transformBooleanReply);
}
exports.transformBooleanArrayReply = transformBooleanArrayReply;
function pushScanArguments(args, cursor, options) {
  args.push(cursor.toString());
  if (options !== null && options !== void 0 && options.MATCH) {
    args.push('MATCH', options.MATCH);
  }
  if (options !== null && options !== void 0 && options.COUNT) {
    args.push('COUNT', options.COUNT.toString());
  }
  return args;
}
exports.pushScanArguments = pushScanArguments;
function transformNumberInfinityReply(reply) {
  switch (reply.toString()) {
    case '+inf':
      return Infinity;
    case '-inf':
      return -Infinity;
    default:
      return Number(reply);
  }
}
exports.transformNumberInfinityReply = transformNumberInfinityReply;
function transformNumberInfinityNullReply(reply) {
  if (reply === null) return null;
  return transformNumberInfinityReply(reply);
}
exports.transformNumberInfinityNullReply = transformNumberInfinityNullReply;
function transformNumberInfinityNullArrayReply(reply) {
  return reply.map(transformNumberInfinityNullReply);
}
exports.transformNumberInfinityNullArrayReply = transformNumberInfinityNullArrayReply;
function transformNumberInfinityArgument(num) {
  switch (num) {
    case Infinity:
      return '+inf';
    case -Infinity:
      return '-inf';
    default:
      return num.toString();
  }
}
exports.transformNumberInfinityArgument = transformNumberInfinityArgument;
function transformStringNumberInfinityArgument(num) {
  if (typeof num !== 'number') return num;
  return transformNumberInfinityArgument(num);
}
exports.transformStringNumberInfinityArgument = transformStringNumberInfinityArgument;
function transformTuplesReply(reply) {
  var message = Object.create(null);
  for (var i = 0; i < reply.length; i += 2) {
    message[reply[i].toString()] = reply[i + 1];
  }
  return message;
}
exports.transformTuplesReply = transformTuplesReply;
function transformStreamMessagesReply(reply) {
  var messages = [];
  var _iterator = _createForOfIteratorHelper(reply),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        id = _step$value[0],
        message = _step$value[1];
      messages.push({
        id: id,
        message: transformTuplesReply(message)
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return messages;
}
exports.transformStreamMessagesReply = transformStreamMessagesReply;
function transformStreamsMessagesReply(reply) {
  if (reply === null) return null;
  return reply.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      name = _ref2[0],
      rawMessages = _ref2[1];
    return {
      name: name,
      messages: transformStreamMessagesReply(rawMessages)
    };
  });
}
exports.transformStreamsMessagesReply = transformStreamsMessagesReply;
function transformSortedSetMemberNullReply(reply) {
  if (!reply.length) return null;
  return transformSortedSetMemberReply(reply);
}
exports.transformSortedSetMemberNullReply = transformSortedSetMemberNullReply;
function transformSortedSetMemberReply(reply) {
  return {
    value: reply[0],
    score: transformNumberInfinityReply(reply[1])
  };
}
exports.transformSortedSetMemberReply = transformSortedSetMemberReply;
function transformSortedSetWithScoresReply(reply) {
  var members = [];
  for (var i = 0; i < reply.length; i += 2) {
    members.push({
      value: reply[i],
      score: transformNumberInfinityReply(reply[i + 1])
    });
  }
  return members;
}
exports.transformSortedSetWithScoresReply = transformSortedSetWithScoresReply;
function transformZMPopArguments(args, keys, side, options) {
  pushVerdictArgument(args, keys);
  args.push(side);
  if (options !== null && options !== void 0 && options.COUNT) {
    args.push('COUNT', options.COUNT.toString());
  }
  return args;
}
exports.transformZMPopArguments = transformZMPopArguments;
function transformLMPopArguments(args, keys, side, options) {
  pushVerdictArgument(args, keys);
  args.push(side);
  if (options !== null && options !== void 0 && options.COUNT) {
    args.push('COUNT', options.COUNT.toString());
  }
  return args;
}
exports.transformLMPopArguments = transformLMPopArguments;
function pushGeoCountArgument(args, count) {
  if (typeof count === 'number') {
    args.push('COUNT', count.toString());
  } else if (count) {
    args.push('COUNT', count.value.toString());
    if (count.ANY) {
      args.push('ANY');
    }
  }
  return args;
}
exports.pushGeoCountArgument = pushGeoCountArgument;
function pushGeoSearchArguments(args, key, from, by, options) {
  args.push(key);
  if (typeof from === 'string') {
    args.push('FROMMEMBER', from);
  } else {
    args.push('FROMLONLAT', from.longitude.toString(), from.latitude.toString());
  }
  if ('radius' in by) {
    args.push('BYRADIUS', by.radius.toString());
  } else {
    args.push('BYBOX', by.width.toString(), by.height.toString());
  }
  args.push(by.unit);
  if (options !== null && options !== void 0 && options.SORT) {
    args.push(options.SORT);
  }
  pushGeoCountArgument(args, options === null || options === void 0 ? void 0 : options.COUNT);
  return args;
}
exports.pushGeoSearchArguments = pushGeoSearchArguments;
function pushGeoRadiusArguments(args, key, from, radius, unit, options) {
  args.push(key);
  if (typeof from === 'string') {
    args.push(from);
  } else {
    args.push(from.longitude.toString(), from.latitude.toString());
  }
  args.push(radius.toString(), unit);
  if (options !== null && options !== void 0 && options.SORT) {
    args.push(options.SORT);
  }
  pushGeoCountArgument(args, options === null || options === void 0 ? void 0 : options.COUNT);
  return args;
}
exports.pushGeoRadiusArguments = pushGeoRadiusArguments;
function pushGeoRadiusStoreArguments(args, key, from, radius, unit, destination, options) {
  pushGeoRadiusArguments(args, key, from, radius, unit, options);
  if (options !== null && options !== void 0 && options.STOREDIST) {
    args.push('STOREDIST', destination);
  } else {
    args.push('STORE', destination);
  }
  return args;
}
exports.pushGeoRadiusStoreArguments = pushGeoRadiusStoreArguments;
var GeoReplyWith;
(function (GeoReplyWith) {
  GeoReplyWith["DISTANCE"] = "WITHDIST";
  GeoReplyWith["HASH"] = "WITHHASH";
  GeoReplyWith["COORDINATES"] = "WITHCOORD";
})(GeoReplyWith = exports.GeoReplyWith || (exports.GeoReplyWith = {}));
function transformGeoMembersWithReply(reply, replyWith) {
  var replyWithSet = new Set(replyWith);
  var index = 0;
  var distanceIndex = replyWithSet.has(GeoReplyWith.DISTANCE) && ++index,
    hashIndex = replyWithSet.has(GeoReplyWith.HASH) && ++index,
    coordinatesIndex = replyWithSet.has(GeoReplyWith.COORDINATES) && ++index;
  return reply.map(function (member) {
    var transformedMember = {
      member: member[0]
    };
    if (distanceIndex) {
      transformedMember.distance = member[distanceIndex];
    }
    if (hashIndex) {
      transformedMember.hash = member[hashIndex];
    }
    if (coordinatesIndex) {
      var _member$coordinatesIn = _slicedToArray(member[coordinatesIndex], 2),
        longitude = _member$coordinatesIn[0],
        latitude = _member$coordinatesIn[1];
      transformedMember.coordinates = {
        longitude: longitude,
        latitude: latitude
      };
    }
    return transformedMember;
  });
}
exports.transformGeoMembersWithReply = transformGeoMembersWithReply;
function transformEXAT(EXAT) {
  return (typeof EXAT === 'number' ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
}
exports.transformEXAT = transformEXAT;
function transformPXAT(PXAT) {
  return (typeof PXAT === 'number' ? PXAT : PXAT.getTime()).toString();
}
exports.transformPXAT = transformPXAT;
function evalFirstKeyIndex(options) {
  var _options$keys;
  return options === null || options === void 0 ? void 0 : (_options$keys = options.keys) === null || _options$keys === void 0 ? void 0 : _options$keys[0];
}
exports.evalFirstKeyIndex = evalFirstKeyIndex;
function pushEvalArguments(args, options) {
  if (options !== null && options !== void 0 && options.keys) {
    args.push.apply(args, [options.keys.length.toString()].concat(_toConsumableArray(options.keys)));
  } else {
    args.push('0');
  }
  if (options !== null && options !== void 0 && options.arguments) {
    args.push.apply(args, _toConsumableArray(options.arguments));
  }
  return args;
}
exports.pushEvalArguments = pushEvalArguments;
function pushVerdictArguments(args, value) {
  if (Array.isArray(value)) {
    // https://github.com/redis/node-redis/pull/2160
    args = args.concat(value);
  } else {
    args.push(value);
  }
  return args;
}
exports.pushVerdictArguments = pushVerdictArguments;
function pushVerdictNumberArguments(args, value) {
  if (Array.isArray(value)) {
    var _iterator2 = _createForOfIteratorHelper(value),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var item = _step2.value;
        args.push(item.toString());
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  } else {
    args.push(value.toString());
  }
  return args;
}
exports.pushVerdictNumberArguments = pushVerdictNumberArguments;
function pushVerdictArgument(args, value) {
  if (Array.isArray(value)) {
    args.push.apply(args, [value.length.toString()].concat(_toConsumableArray(value)));
  } else {
    args.push('1', value);
  }
  return args;
}
exports.pushVerdictArgument = pushVerdictArgument;
function pushOptionalVerdictArgument(args, name, value) {
  if (value === undefined) return args;
  args.push(name);
  return pushVerdictArgument(args, value);
}
exports.pushOptionalVerdictArgument = pushOptionalVerdictArgument;
var CommandFlags;
(function (CommandFlags) {
  CommandFlags["WRITE"] = "write";
  CommandFlags["READONLY"] = "readonly";
  CommandFlags["DENYOOM"] = "denyoom";
  CommandFlags["ADMIN"] = "admin";
  CommandFlags["PUBSUB"] = "pubsub";
  CommandFlags["NOSCRIPT"] = "noscript";
  CommandFlags["RANDOM"] = "random";
  CommandFlags["SORT_FOR_SCRIPT"] = "sort_for_script";
  CommandFlags["LOADING"] = "loading";
  CommandFlags["STALE"] = "stale";
  CommandFlags["SKIP_MONITOR"] = "skip_monitor";
  CommandFlags["ASKING"] = "asking";
  CommandFlags["FAST"] = "fast";
  CommandFlags["MOVABLEKEYS"] = "movablekeys"; // keys have no pre-determined position. You must discover keys yourself.
})(CommandFlags = exports.CommandFlags || (exports.CommandFlags = {}));
var CommandCategories;
(function (CommandCategories) {
  CommandCategories["KEYSPACE"] = "@keyspace";
  CommandCategories["READ"] = "@read";
  CommandCategories["WRITE"] = "@write";
  CommandCategories["SET"] = "@set";
  CommandCategories["SORTEDSET"] = "@sortedset";
  CommandCategories["LIST"] = "@list";
  CommandCategories["HASH"] = "@hash";
  CommandCategories["STRING"] = "@string";
  CommandCategories["BITMAP"] = "@bitmap";
  CommandCategories["HYPERLOGLOG"] = "@hyperloglog";
  CommandCategories["GEO"] = "@geo";
  CommandCategories["STREAM"] = "@stream";
  CommandCategories["PUBSUB"] = "@pubsub";
  CommandCategories["ADMIN"] = "@admin";
  CommandCategories["FAST"] = "@fast";
  CommandCategories["SLOW"] = "@slow";
  CommandCategories["BLOCKING"] = "@blocking";
  CommandCategories["DANGEROUS"] = "@dangerous";
  CommandCategories["CONNECTION"] = "@connection";
  CommandCategories["TRANSACTION"] = "@transaction";
  CommandCategories["SCRIPTING"] = "@scripting";
})(CommandCategories = exports.CommandCategories || (exports.CommandCategories = {}));
function transformCommandReply(_ref3) {
  var _ref4 = _slicedToArray(_ref3, 7),
    name = _ref4[0],
    arity = _ref4[1],
    flags = _ref4[2],
    firstKeyIndex = _ref4[3],
    lastKeyIndex = _ref4[4],
    step = _ref4[5],
    categories = _ref4[6];
  return {
    name: name,
    arity: arity,
    flags: new Set(flags),
    firstKeyIndex: firstKeyIndex,
    lastKeyIndex: lastKeyIndex,
    step: step,
    categories: new Set(categories)
  };
}
exports.transformCommandReply = transformCommandReply;
var RedisFunctionFlags;
(function (RedisFunctionFlags) {
  RedisFunctionFlags["NO_WRITES"] = "no-writes";
  RedisFunctionFlags["ALLOW_OOM"] = "allow-oom";
  RedisFunctionFlags["ALLOW_STALE"] = "allow-stale";
  RedisFunctionFlags["NO_CLUSTER"] = "no-cluster";
})(RedisFunctionFlags = exports.RedisFunctionFlags || (exports.RedisFunctionFlags = {}));
function transformFunctionListItemReply(reply) {
  return {
    libraryName: reply[1],
    engine: reply[3],
    functions: reply[5].map(function (fn) {
      return {
        name: fn[1],
        description: fn[3],
        flags: fn[5]
      };
    })
  };
}
exports.transformFunctionListItemReply = transformFunctionListItemReply;
function pushSortArguments(args, options) {
  if (options !== null && options !== void 0 && options.BY) {
    args.push('BY', options.BY);
  }
  if (options !== null && options !== void 0 && options.LIMIT) {
    args.push('LIMIT', options.LIMIT.offset.toString(), options.LIMIT.count.toString());
  }
  if (options !== null && options !== void 0 && options.GET) {
    var _iterator3 = _createForOfIteratorHelper(typeof options.GET === 'string' ? [options.GET] : options.GET),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var pattern = _step3.value;
        args.push('GET', pattern);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  if (options !== null && options !== void 0 && options.DIRECTION) {
    args.push(options.DIRECTION);
  }
  if (options !== null && options !== void 0 && options.ALPHA) {
    args.push('ALPHA');
  }
  return args;
}
exports.pushSortArguments = pushSortArguments;
function pushSlotRangeArguments(args, range) {
  args.push(range.start.toString(), range.end.toString());
}
function pushSlotRangesArguments(args, ranges) {
  if (Array.isArray(ranges)) {
    var _iterator4 = _createForOfIteratorHelper(ranges),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var range = _step4.value;
        pushSlotRangeArguments(args, range);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  } else {
    pushSlotRangeArguments(args, ranges);
  }
  return args;
}
exports.pushSlotRangesArguments = pushSlotRangesArguments;
function transformRangeReply(_ref5) {
  var _ref6 = _slicedToArray(_ref5, 2),
    start = _ref6[0],
    end = _ref6[1];
  return {
    start: start,
    end: end
  };
}
exports.transformRangeReply = transformRangeReply;