"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringify = stringify;
var _types = require("./types");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var attribValChars = ["\\", '"'];
var pseudoValChars = [].concat(attribValChars, ["(", ")"]);
var charsToEscapeInAttributeValue = new Set(attribValChars.map(function (c) {
  return c.charCodeAt(0);
}));
var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function (c) {
  return c.charCodeAt(0);
}));
var charsToEscapeInName = new Set([].concat(_toConsumableArray(pseudoValChars), ["~", "^", "$", "*", "+", "!", "|", ":", "[", "]", " ", "."]).map(function (c) {
  return c.charCodeAt(0);
}));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
  return selector.map(function (token) {
    return token.map(stringifyToken).join("");
  }).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    // Simple types
    case _types.SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case _types.SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case _types.SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case _types.SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case _types.SelectorType.Descendant:
      return " ";
    case _types.SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case _types.SelectorType.Universal:
      // Return an empty string if the selector isn't needed.
      return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
    case _types.SelectorType.Tag:
      return getNamespacedName(token);
    case _types.SelectorType.PseudoElement:
      return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
    case _types.SelectorType.Pseudo:
      return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
    case _types.SelectorType.Attribute:
      {
        if (token.name === "id" && token.action === _types.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
          return "#".concat(escapeName(token.value, charsToEscapeInName));
        }
        if (token.name === "class" && token.action === _types.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
          return ".".concat(escapeName(token.value, charsToEscapeInName));
        }
        var name = getNamespacedName(token);
        if (token.action === _types.AttributeAction.Exists) {
          return "[".concat(name, "]");
        }
        return "[".concat(name).concat(getActionValue(token.action), "=\"").concat(escapeName(token.value, charsToEscapeInAttributeValue), "\"").concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
      }
  }
}
function getActionValue(action) {
  switch (action) {
    case _types.AttributeAction.Equals:
      return "";
    case _types.AttributeAction.Element:
      return "~";
    case _types.AttributeAction.Start:
      return "^";
    case _types.AttributeAction.End:
      return "$";
    case _types.AttributeAction.Any:
      return "*";
    case _types.AttributeAction.Not:
      return "!";
    case _types.AttributeAction.Hyphen:
      return "|";
    case _types.AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
}
function getNamespace(namespace) {
  return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
}
function escapeName(str, charsToEscape) {
  var lastIdx = 0;
  var ret = "";
  for (var i = 0; i < str.length; i++) {
    if (charsToEscape.has(str.charCodeAt(i))) {
      ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
      lastIdx = i + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}