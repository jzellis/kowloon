'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var sliceAnsi = require('slice-ansi');
var stringWidth = require('string-width');
function getIndexOfNearestSpace(string, index, shouldSearchRight) {
  if (string.charAt(index) === ' ') {
    return index;
  }
  for (var i = 1; i <= 3; i++) {
    if (shouldSearchRight) {
      if (string.charAt(index + i) === ' ') {
        return index + i;
      }
    } else if (string.charAt(index - i) === ' ') {
      return index - i;
    }
  }
  return index;
}
module.exports = function (text, columns, options) {
  options = _objectSpread({
    position: 'end',
    preferTruncationOnSpace: false
  }, options);
  var _options = options,
    position = _options.position,
    space = _options.space,
    preferTruncationOnSpace = _options.preferTruncationOnSpace;
  var ellipsis = 'â€¦';
  var ellipsisWidth = 1;
  if (typeof text !== 'string') {
    throw new TypeError("Expected `input` to be a string, got ".concat(_typeof(text)));
  }
  if (typeof columns !== 'number') {
    throw new TypeError("Expected `columns` to be a number, got ".concat(_typeof(columns)));
  }
  if (columns < 1) {
    return '';
  }
  if (columns === 1) {
    return ellipsis;
  }
  var length = stringWidth(text);
  if (length <= columns) {
    return text;
  }
  if (position === 'start') {
    if (preferTruncationOnSpace) {
      var nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
      return ellipsis + sliceAnsi(text, nearestSpace, length).trim();
    }
    if (space === true) {
      ellipsis += ' ';
      ellipsisWidth = 2;
    }
    return ellipsis + sliceAnsi(text, length - columns + ellipsisWidth, length);
  }
  if (position === 'middle') {
    if (space === true) {
      ellipsis = ' ' + ellipsis + ' ';
      ellipsisWidth = 3;
    }
    var half = Math.floor(columns / 2);
    if (preferTruncationOnSpace) {
      var spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
      var spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
      return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + ellipsis + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
    }
    return sliceAnsi(text, 0, half) + ellipsis + sliceAnsi(text, length - (columns - half) + ellipsisWidth, length);
  }
  if (position === 'end') {
    if (preferTruncationOnSpace) {
      var _nearestSpace = getIndexOfNearestSpace(text, columns - 1);
      return sliceAnsi(text, 0, _nearestSpace) + ellipsis;
    }
    if (space === true) {
      ellipsis = ' ' + ellipsis;
      ellipsisWidth = 2;
    }
    return sliceAnsi(text, 0, columns - ellipsisWidth) + ellipsis;
  }
  throw new Error("Expected `options.position` to be either `start`, `middle` or `end`, got ".concat(position));
};