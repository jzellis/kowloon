'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var isTerm = process.env.TERM_PROGRAM === 'Apple_Terminal';
var colors = require('ansi-colors');
var utils = require('./utils');
var ansi = module.exports = exports;
var ESC = "\x1B[";
var BEL = "\x07";
var hidden = false;
var code = ansi.code = {
  bell: BEL,
  beep: BEL,
  beginning: "".concat(ESC, "G"),
  down: "".concat(ESC, "J"),
  esc: ESC,
  getPosition: "".concat(ESC, "6n"),
  hide: "".concat(ESC, "?25l"),
  line: "".concat(ESC, "2K"),
  lineEnd: "".concat(ESC, "K"),
  lineStart: "".concat(ESC, "1K"),
  restorePosition: ESC + (isTerm ? '8' : 'u'),
  savePosition: ESC + (isTerm ? '7' : 's'),
  screen: "".concat(ESC, "2J"),
  show: "".concat(ESC, "?25h"),
  up: "".concat(ESC, "1J")
};
var cursor = ansi.cursor = {
  get hidden() {
    return hidden;
  },
  hide: function hide() {
    hidden = true;
    return code.hide;
  },
  show: function show() {
    hidden = false;
    return code.show;
  },
  forward: function forward() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC).concat(count, "C");
  },
  backward: function backward() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC).concat(count, "D");
  },
  nextLine: function nextLine() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC, "E").repeat(count);
  },
  prevLine: function prevLine() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC, "F").repeat(count);
  },
  up: function up() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "A") : '';
  },
  down: function down() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "B") : '';
  },
  right: function right() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "C") : '';
  },
  left: function left() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "D") : '';
  },
  to: function to(x, y) {
    return y ? "".concat(ESC).concat(y + 1, ";").concat(x + 1, "H") : "".concat(ESC).concat(x + 1, "G");
  },
  move: function move() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var res = '';
    res += x < 0 ? cursor.left(-x) : x > 0 ? cursor.right(x) : '';
    res += y < 0 ? cursor.up(-y) : y > 0 ? cursor.down(y) : '';
    return res;
  },
  restore: function restore() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var after = state.after,
      cursor = state.cursor,
      initial = state.initial,
      input = state.input,
      prompt = state.prompt,
      size = state.size,
      value = state.value;
    initial = utils.isPrimitive(initial) ? String(initial) : '';
    input = utils.isPrimitive(input) ? String(input) : '';
    value = utils.isPrimitive(value) ? String(value) : '';
    if (size) {
      var codes = ansi.cursor.up(size) + ansi.cursor.to(prompt.length);
      var diff = input.length - cursor;
      if (diff > 0) {
        codes += ansi.cursor.left(diff);
      }
      return codes;
    }
    if (value || after) {
      var pos = !input && !!initial ? -initial.length : -input.length + cursor;
      if (after) pos -= after.length;
      if (input === '' && initial && !prompt.includes(initial)) {
        pos += initial.length;
      }
      return ansi.cursor.move(pos);
    }
  }
};
var erase = ansi.erase = {
  screen: code.screen,
  up: code.up,
  down: code.down,
  line: code.line,
  lineEnd: code.lineEnd,
  lineStart: code.lineStart,
  lines: function lines(n) {
    var str = '';
    for (var i = 0; i < n; i++) {
      str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : '');
    }
    if (n) str += ansi.code.beginning;
    return str;
  }
};
ansi.clear = function () {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.stdout.columns;
  if (!columns) return erase.line + cursor.to(0);
  var width = function width(str) {
    return _toConsumableArray(colors.unstyle(str)).length;
  };
  var lines = input.split(/\r?\n/);
  var rows = 0;
  var _iterator = _createForOfIteratorHelper(lines),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
};