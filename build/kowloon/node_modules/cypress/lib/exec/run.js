"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var _ = require('lodash');
var debug = require('debug')('cypress:cli:run');
var util = require('../util');
var spawn = require('./spawn');
var verify = require('../tasks/verify');
var _require = require('../errors'),
  exitWithError = _require.exitWithError,
  errors = _require.errors;
var _require2 = require('./shared'),
  processTestingType = _require2.processTestingType,
  throwInvalidOptionError = _require2.throwInvalidOptionError,
  checkConfigFile = _require2.checkConfigFile;

/**
 * Typically a user passes a string path to the project.
 * But "cypress open" allows using `false` to open in global mode,
 * and the user can accidentally execute `cypress run --project false`
 * which should be invalid.
 */
var isValidProject = function isValidProject(v) {
  if (typeof v === 'boolean') {
    return false;
  }
  if (v === '' || v === 'false' || v === 'true') {
    return false;
  }
  return true;
};

/**
 * Maps options collected by the CLI
 * and forms list of CLI arguments to the server.
 *
 * Note: there is lightweight validation, with errors
 * thrown synchronously.
 *
 * @returns {string[]} list of CLI arguments
 */
var processRunOptions = function processRunOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  debug('processing run options %o', options);
  if (!isValidProject(options.project)) {
    debug('invalid project option %o', {
      project: options.project
    });
    return throwInvalidOptionError(errors.invalidRunProjectPath);
  }
  var args = ['--run-project', options.project];
  if (options.autoCancelAfterFailures || options.autoCancelAfterFailures === 0 || options.autoCancelAfterFailures === false) {
    args.push('--auto-cancel-after-failures', options.autoCancelAfterFailures);
  }
  if (options.browser) {
    args.push('--browser', options.browser);
  }
  if (options.ciBuildId) {
    args.push('--ci-build-id', options.ciBuildId);
  }
  if (options.config) {
    args.push('--config', options.config);
  }
  if (options.configFile !== undefined) {
    checkConfigFile(options);
    args.push('--config-file', options.configFile);
  }
  if (options.env) {
    args.push('--env', options.env);
  }
  if (options.exit === false) {
    args.push('--no-exit');
  }
  if (options.group) {
    args.push('--group', options.group);
  }
  if (options.headed) {
    args.push('--headed', options.headed);
  }
  if (options.headless) {
    if (options.headed) {
      return throwInvalidOptionError(errors.incompatibleHeadlessFlags);
    }
    args.push('--headed', !options.headless);
  }

  // if key is set use that - else attempt to find it by environment variable
  if (options.key == null) {
    debug('--key is not set, looking up environment variable CYPRESS_RECORD_KEY');
    options.key = util.getEnv('CYPRESS_RECORD_KEY');
  }

  // if we have a key assume we're in record mode
  if (options.key) {
    args.push('--key', options.key);
  }
  if (options.outputPath) {
    args.push('--output-path', options.outputPath);
  }
  if (options.parallel) {
    args.push('--parallel');
  }
  if (options.port) {
    args.push('--port', options.port);
  }
  if (options.quiet) {
    args.push('--quiet');
  }

  // if record is defined and we're not
  // already in ci mode, then send it up
  if (options.record != null) {
    args.push('--record', options.record);
  }

  // if we have a specific reporter push that into the args
  if (options.reporter) {
    args.push('--reporter', options.reporter);
  }

  // if we have a specific reporter push that into the args
  if (options.reporterOptions) {
    args.push('--reporter-options', options.reporterOptions);
  }

  // if we have specific spec(s) push that into the args
  if (options.spec) {
    args.push('--spec', options.spec);
  }
  if (options.tag) {
    args.push('--tag', options.tag);
  }
  if (options.inspect) {
    args.push('--inspect');
  }
  if (options.inspectBrk) {
    args.push('--inspectBrk');
  }
  args.push.apply(args, _toConsumableArray(processTestingType(options)));
  return args;
};
module.exports = {
  processRunOptions: processRunOptions,
  isValidProject: isValidProject,
  // resolves with the number of failed tests
  start: function start() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _.defaults(options, {
      key: null,
      spec: null,
      reporter: null,
      reporterOptions: null,
      project: process.cwd()
    });
    function run() {
      try {
        var args = processRunOptions(options);
        debug('run to spawn.start args %j', args);
        return spawn.start(args, {
          dev: options.dev
        });
      } catch (err) {
        if (err.details) {
          return exitWithError(err.details)();
        }
        throw err;
      }
    }
    if (options.dev) {
      return run();
    }
    return verify.start().then(run);
  }
};