"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLACEHOLDER_ELEMENT = void 0;
exports.ensureIsTag = ensureIsTag;
exports.getNextSiblings = getNextSiblings;
exports.subselects = void 0;
var _boolbase = _interopRequireDefault(require("boolbase"));
var _sort = require("../sort.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/** Used as a placeholder for :has. Will be replaced with the actual element. */
var PLACEHOLDER_ELEMENT = {};
exports.PLACEHOLDER_ELEMENT = PLACEHOLDER_ELEMENT;
function ensureIsTag(next, adapter) {
  if (next === _boolbase["default"].falseFunc) return _boolbase["default"].falseFunc;
  return function (elem) {
    return adapter.isTag(elem) && next(elem);
  };
}
function getNextSiblings(elem, adapter) {
  var siblings = adapter.getSiblings(elem);
  if (siblings.length <= 1) return [];
  var elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
  return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
function copyOptions(options) {
  // Not copied: context, rootFunc
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is = function is(next, token, options, context, compileToken) {
  var func = compileToken(token, copyOptions(options), context);
  return func === _boolbase["default"].trueFunc ? next : func === _boolbase["default"].falseFunc ? _boolbase["default"].falseFunc : function (elem) {
    return func(elem) && next(elem);
  };
};
/*
 * :not, :has, :is, :matches and :where have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
var subselects = {
  is: is,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is,
  where: is,
  not: function not(next, token, options, context, compileToken) {
    var func = compileToken(token, copyOptions(options), context);
    return func === _boolbase["default"].falseFunc ? next : func === _boolbase["default"].trueFunc ? _boolbase["default"].falseFunc : function (elem) {
      return !func(elem) && next(elem);
    };
  },
  has: function has(next, subselect, options, _context, compileToken) {
    var adapter = options.adapter;
    var opts = copyOptions(options);
    opts.relativeSelector = true;
    var context = subselect.some(function (s) {
      return s.some(_sort.isTraversal);
    }) ?
    // Used as a placeholder. Will be replaced with the actual element.
    [PLACEHOLDER_ELEMENT] : undefined;
    var compiled = compileToken(subselect, opts, context);
    if (compiled === _boolbase["default"].falseFunc) return _boolbase["default"].falseFunc;
    var hasElement = ensureIsTag(compiled, adapter);
    // If `compiled` is `trueFunc`, we can skip this.
    if (context && compiled !== _boolbase["default"].trueFunc) {
      /*
       * `shouldTestNextSiblings` will only be true if the query starts with
       * a traversal (sibling or adjacent). That means we will always have a context.
       */
      var _compiled$shouldTestN = compiled.shouldTestNextSiblings,
        shouldTestNextSiblings = _compiled$shouldTestN === void 0 ? false : _compiled$shouldTestN;
      return function (elem) {
        if (!next(elem)) return false;
        context[0] = elem;
        var childs = adapter.getChildren(elem);
        var nextElements = shouldTestNextSiblings ? [].concat(_toConsumableArray(childs), _toConsumableArray(getNextSiblings(elem, adapter))) : childs;
        return adapter.existsOne(hasElement, nextElements);
      };
    }
    return function (elem) {
      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
    };
  }
};
exports.subselects = subselects;