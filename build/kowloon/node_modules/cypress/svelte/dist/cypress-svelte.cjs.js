/**
 * @cypress/svelte v0.0.0-development
 * (c) 2023 Cypress.io
 * Released under the MIT License
 */

'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var ROOT_SELECTOR = '[data-cy-root]';
/**
 * Gets the root element used to mount the component.
 * @returns {HTMLElement} The root element
 * @throws {Error} If the root element is not found
 */
var getContainerEl = function getContainerEl() {
  var el = document.querySelector(ROOT_SELECTOR);
  if (el) {
    return el;
  }
  throw Error("No element found that matches selector ".concat(ROOT_SELECTOR, ". Please add a root element with data-cy-root attribute to your \"component-index.html\" file so that Cypress can attach your component to the DOM."));
};
function checkForRemovedStyleOptions(mountingOptions) {
  for (var _i = 0, _arr = ['cssFile', 'cssFiles', 'style', 'styles', 'stylesheet', 'stylesheets']; _i < _arr.length; _i++) {
    var key = _arr[_i];
    if (mountingOptions[key]) {
      Cypress.utils.throwErrByPath('mount.removed_style_mounting_options', key);
    }
  }
}
/**
 * Utility function to register CT side effects and run cleanup code during the "test:before:run" Cypress hook
 * @param optionalCallback Callback to be called before the next test runs
 */
function setupHooks(optionalCallback) {
  // We don't want CT side effects to run when e2e
  // testing so we early return.
  // System test to verify CT side effects do not pollute e2e: system-tests/test/e2e_with_mount_import_spec.ts
  if (Cypress.testingType !== 'component') {
    return;
  }
  // When running component specs, we cannot allow "cy.visit"
  // because it will wipe out our preparation work, and does not make much sense
  // thus we overwrite "cy.visit" to throw an error
  Cypress.Commands.overwrite('visit', function () {
    throw new Error('cy.visit from a component spec is not allowed');
  });
  Cypress.Commands.overwrite('session', function () {
    throw new Error('cy.session from a component spec is not allowed');
  });
  Cypress.Commands.overwrite('origin', function () {
    throw new Error('cy.origin from a component spec is not allowed');
  });
  // @ts-ignore
  Cypress.on('test:before:run', function () {
    optionalCallback === null || optionalCallback === void 0 ? void 0 : optionalCallback();
  });
}
var DEFAULT_COMP_NAME = 'unknown';
var componentInstance;
var cleanup = function cleanup() {
  componentInstance === null || componentInstance === void 0 ? void 0 : componentInstance.$destroy();
};
// Extract the component name from the object passed to mount
var getComponentDisplayName = function getComponentDisplayName(Component) {
  if (Component.name) {
    var _ref = /Proxy\<(\w+)\>/.exec(Component.name) || [],
      _ref2 = _slicedToArray(_ref, 2),
      match = _ref2[1];
    return match || Component.name;
  }
  return DEFAULT_COMP_NAME;
};
/**
 * Mounts a Svelte component inside the Cypress browser
 *
 * @param {SvelteConstructor<T>} Component Svelte component being mounted
 * @param {MountReturn<T extends SvelteComponent>} options options to customize the component being mounted
 * @returns Cypress.Chainable<MountReturn>
 *
 * @example
 * import Counter from './Counter.svelte'
 * import { mount } from 'cypress/svelte'
 *
 * it('should render', () => {
 *   mount(Counter, { props: { count: 42 } })
 *   cy.get('button').contains(42)
 * })
 *
 * @see {@link https://on.cypress.io/mounting-svelte} for more details.
 */
function mount(Component) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  checkForRemovedStyleOptions(options);
  return cy.then(function () {
    // Remove last mounted component if cy.mount is called more than once in a test
    cleanup();
    var target = getContainerEl();
    var ComponentConstructor = Component["default"] || Component;
    componentInstance = new ComponentConstructor(Object.assign({
      target: target
    }, options));
    // by waiting, we are delaying test execution for the next tick of event loop
    // and letting hooks and component lifecycle methods to execute mount
    return cy.wait(0, {
      log: false
    }).then(function () {
      if (options.log !== false) {
        var mountMessage = "<".concat(getComponentDisplayName(Component), " ... />");
        Cypress.log({
          name: 'mount',
          message: [mountMessage]
        });
      }
    }).wrap({
      component: componentInstance
    }, {
      log: false
    });
  });
}
// Side effects from "import { mount } from '@cypress/<my-framework>'" are annoying, we should avoid doing this
// by creating an explicit function/import that the user can register in their 'component.js' support file,
// such as:
//    import 'cypress/<my-framework>/support'
// or
//    import { registerCT } from 'cypress/<my-framework>'
//    registerCT()
// Note: This would be a breaking change
setupHooks(cleanup);
exports.mount = mount;