"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filters = void 0;
var _nthCheck = _interopRequireDefault(require("nth-check"));
var _boolbase = _interopRequireDefault(require("boolbase"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function getChildFunc(next, adapter) {
  return function (elem) {
    var parent = adapter.getParent(elem);
    return parent != null && adapter.isTag(parent) && next(elem);
  };
}
var filters = {
  contains: function contains(next, text, _ref) {
    var adapter = _ref.adapter;
    return function contains(elem) {
      return next(elem) && adapter.getText(elem).includes(text);
    };
  },
  icontains: function icontains(next, text, _ref2) {
    var adapter = _ref2.adapter;
    var itext = text.toLowerCase();
    return function icontains(elem) {
      return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child": function nthChild(next, rule, _ref3) {
    var adapter = _ref3.adapter,
      equals = _ref3.equals;
    var func = (0, _nthCheck["default"])(rule);
    if (func === _boolbase["default"].falseFunc) return _boolbase["default"].falseFunc;
    if (func === _boolbase["default"].trueFunc) return getChildFunc(next, adapter);
    return function nthChild(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = 0; i < siblings.length; i++) {
        if (equals(elem, siblings[i])) break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child": function nthLastChild(next, rule, _ref4) {
    var adapter = _ref4.adapter,
      equals = _ref4.equals;
    var func = (0, _nthCheck["default"])(rule);
    if (func === _boolbase["default"].falseFunc) return _boolbase["default"].falseFunc;
    if (func === _boolbase["default"].trueFunc) return getChildFunc(next, adapter);
    return function nthLastChild(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = siblings.length - 1; i >= 0; i--) {
        if (equals(elem, siblings[i])) break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type": function nthOfType(next, rule, _ref5) {
    var adapter = _ref5.adapter,
      equals = _ref5.equals;
    var func = (0, _nthCheck["default"])(rule);
    if (func === _boolbase["default"].falseFunc) return _boolbase["default"].falseFunc;
    if (func === _boolbase["default"].trueFunc) return getChildFunc(next, adapter);
    return function nthOfType(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = 0; i < siblings.length; i++) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling)) break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type": function nthLastOfType(next, rule, _ref6) {
    var adapter = _ref6.adapter,
      equals = _ref6.equals;
    var func = (0, _nthCheck["default"])(rule);
    if (func === _boolbase["default"].falseFunc) return _boolbase["default"].falseFunc;
    if (func === _boolbase["default"].trueFunc) return getChildFunc(next, adapter);
    return function nthLastOfType(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = siblings.length - 1; i >= 0; i--) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling)) break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root: function root(next, _rule, _ref7) {
    var adapter = _ref7.adapter;
    return function (elem) {
      var parent = adapter.getParent(elem);
      return (parent == null || !adapter.isTag(parent)) && next(elem);
    };
  },
  scope: function scope(next, rule, options, context) {
    var equals = options.equals;
    if (!context || context.length === 0) {
      // Equivalent to :root
      return filters["root"](next, rule, options);
    }
    if (context.length === 1) {
      // NOTE: can't be unpacked, as :has uses this for side-effects
      return function (elem) {
        return equals(context[0], elem) && next(elem);
      };
    }
    return function (elem) {
      return context.includes(elem) && next(elem);
    };
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
exports.filters = filters;
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next, _rule, _ref8) {
    var adapter = _ref8.adapter;
    var func = adapter[name];
    if (typeof func !== "function") {
      return _boolbase["default"].falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}