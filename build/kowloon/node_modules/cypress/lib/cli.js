"use strict";

// @ts-check
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var _ = require('lodash');
var commander = require('commander');
var _require = require('common-tags'),
  stripIndent = _require.stripIndent;
var logSymbols = require('log-symbols');
var debug = require('debug')('cypress:cli:cli');
var util = require('./util');
var logger = require('./logger');
var errors = require('./errors');
var cache = require('./tasks/cache');

// patch "commander" method called when a user passed an unknown option
// we want to print help for the current command and exit with an error
function unknownOption(flag) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'option';
  if (this._allowUnknownOption) return;
  logger.error();
  logger.error("  error: unknown ".concat(type, ":"), flag);
  logger.error();
  this.outputHelp();
  util.exit(1);
}
commander.Command.prototype.unknownOption = unknownOption;
var coerceFalse = function coerceFalse(arg) {
  return arg !== 'false';
};
var coerceAnyStringToInt = function coerceAnyStringToInt(arg) {
  return typeof arg === 'string' ? parseInt(arg) : arg;
};
var spaceDelimitedArgsMsg = function spaceDelimitedArgsMsg(flag, args) {
  var msg = "\n    ".concat(logSymbols.warning, " Warning: It looks like you're passing --").concat(flag, " a space-separated list of arguments:\n\n    \"").concat(args.join(' '), "\"\n\n    This will work, but it's not recommended.\n\n    If you are trying to pass multiple arguments, separate them with commas instead:\n      cypress run --").concat(flag, " arg1,arg2,arg3\n  ");
  if (flag === 'spec') {
    msg += "\n    The most common cause of this warning is using an unescaped glob pattern. If you are\n    trying to pass a glob pattern, escape it using quotes:\n      cypress run --spec \"**/*.spec.js\"\n    ";
  }
  logger.log();
  logger.warn(stripIndent(msg));
  logger.log();
};
var parseVariableOpts = function parseVariableOpts(fnArgs, args) {
  var _fnArgs = _slicedToArray(fnArgs, 2),
    opts = _fnArgs[0],
    unknownArgs = _fnArgs[1];
  if (unknownArgs && unknownArgs.length && (opts.spec || opts.tag)) {
    // this will capture space-delimited args after
    // flags that could have possible multiple args
    // but before the next option
    // --spec spec1 spec2 or --tag foo bar

    var multiArgFlags = _.compact([opts.spec ? 'spec' : opts.spec, opts.tag ? 'tag' : opts.tag]);
    _.forEach(multiArgFlags, function (flag) {
      var argIndex = _.indexOf(args, "--".concat(flag)) + 2;
      var nextOptOffset = _.findIndex(_.slice(args, argIndex), function (arg) {
        return _.startsWith(arg, '--');
      });
      var endIndex = nextOptOffset !== -1 ? argIndex + nextOptOffset : args.length;
      var maybeArgs = _.slice(args, argIndex, endIndex);
      var extraArgs = _.intersection(maybeArgs, unknownArgs);
      if (extraArgs.length) {
        opts[flag] = [opts[flag]].concat(extraArgs);
        spaceDelimitedArgsMsg(flag, opts[flag]);
        opts[flag] = opts[flag].join(',');
      }
    });
  }
  debug('variable-length opts parsed %o', {
    args: args,
    opts: opts
  });
  return util.parseOpts(opts);
};
var descriptions = {
  autoCancelAfterFailures: 'overrides the project-level Cloud configuration to set the failed test threshold for auto cancellation or to disable auto cancellation when recording to the Cloud',
  browser: 'runs Cypress in the browser with the given name. if a filesystem path is supplied, Cypress will attempt to use the browser at that path.',
  cacheClear: 'delete all cached binaries',
  cachePrune: 'deletes all cached binaries except for the version currently in use',
  cacheList: 'list cached binary versions',
  cachePath: 'print the path to the binary cache',
  cacheSize: 'Used with the list command to show the sizes of the cached folders',
  ciBuildId: 'the unique identifier for a run on your CI provider. typically a "BUILD_ID" env var. this value is automatically detected for most CI providers',
  component: 'runs component tests',
  config: 'sets configuration values. separate multiple values with a comma. overrides any value in cypress.config.{js,ts,mjs,cjs}.',
  configFile: 'path to script file where configuration values are set. defaults to "cypress.config.{js,ts,mjs,cjs}".',
  detached: 'runs Cypress application in detached mode',
  dev: 'runs cypress in development and bypasses binary check',
  e2e: 'runs end to end tests',
  env: 'sets environment variables. separate multiple values with a comma. overrides any value in cypress.config.{js,ts,mjs,cjs} or cypress.env.json',
  exit: 'keep the browser open after tests finish',
  forceInstall: 'force install the Cypress binary',
  global: 'force Cypress into global mode as if its globally installed',
  group: 'a named group for recorded runs in Cypress Cloud',
  headed: 'displays the browser instead of running headlessly',
  headless: 'hide the browser instead of running headed (default for cypress run)',
  key: 'your secret Record Key. you can omit this if you set a CYPRESS_RECORD_KEY environment variable.',
  parallel: 'enables concurrent runs and automatic load balancing of specs across multiple machines or processes',
  port: 'runs Cypress on a specific port. overrides any value in cypress.config.{js,ts,mjs,cjs}.',
  project: 'path to the project',
  quiet: 'run quietly, using only the configured reporter',
  record: 'records the run. sends test results, screenshots and videos to Cypress Cloud.',
  reporter: 'runs a specific mocha reporter. pass a path to use a custom reporter. defaults to "spec"',
  reporterOptions: 'options for the mocha reporter. defaults to "null"',
  spec: 'runs specific spec file(s). defaults to "all"',
  tag: 'named tag(s) for recorded runs in Cypress Cloud',
  version: 'prints Cypress version'
};
var knownCommands = ['cache', 'help', '-h', '--help', 'install', 'open', 'run', 'open-ct', 'run-ct', 'verify', '-v', '--version', 'version', 'info'];
var text = function text(description) {
  if (!descriptions[description]) {
    throw new Error("Could not find description for: ".concat(description));
  }
  return descriptions[description];
};
function includesVersion(args) {
  return _.includes(args, '--version') || _.includes(args, '-v');
}
function showVersions(opts) {
  debug('printing Cypress version');
  debug('additional arguments %o', opts);
  debug('parsed version arguments %o', opts);
  var reportAllVersions = function reportAllVersions(versions) {
    logger.always('Cypress package version:', versions["package"]);
    logger.always('Cypress binary version:', versions.binary);
    logger.always('Electron version:', versions.electronVersion);
    logger.always('Bundled Node version:', versions.electronNodeVersion);
  };
  var reportComponentVersion = function reportComponentVersion(componentName, versions) {
    var names = {
      "package": 'package',
      binary: 'binary',
      electron: 'electronVersion',
      node: 'electronNodeVersion'
    };
    if (!names[componentName]) {
      throw new Error("Unknown component name \"".concat(componentName, "\""));
    }
    var name = names[componentName];
    if (!versions[name]) {
      throw new Error("Cannot find version for component \"".concat(componentName, "\" under property \"").concat(name, "\""));
    }
    var version = versions[name];
    logger.always(version);
  };
  var defaultVersions = {
    "package": undefined,
    binary: undefined,
    electronVersion: undefined,
    electronNodeVersion: undefined
  };
  return require('./exec/versions').getVersions().then(function () {
    var versions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultVersions;
    if (opts !== null && opts !== void 0 && opts.component) {
      reportComponentVersion(opts.component, versions);
    } else {
      reportAllVersions(versions);
    }
    process.exit(0);
  })["catch"](util.logErrorExit1);
}
var createProgram = function createProgram() {
  var program = new commander.Command();

  // bug in commander not printing name
  // in usage help docs
  program._name = 'cypress';
  program.usage('<command> [options]');
  return program;
};
var addCypressRunCommand = function addCypressRunCommand(program) {
  return program.command('run').usage('[options]').description('Runs Cypress tests from the CLI without the GUI').option('--auto-cancel-after-failures <test-failure-count || false>', text('autoCancelAfterFailures')).option('-b, --browser <browser-name-or-path>', text('browser')).option('--ci-build-id <id>', text('ciBuildId')).option('--component', text('component')).option('-c, --config <config>', text('config')).option('-C, --config-file <config-file>', text('configFile')).option('--e2e', text('e2e')).option('-e, --env <env>', text('env')).option('--group <name>', text('group')).option('-k, --key <record-key>', text('key')).option('--headed', text('headed')).option('--headless', text('headless')).option('--no-exit', text('exit')).option('--parallel', text('parallel')).option('-p, --port <port>', text('port')).option('-P, --project <project-path>', text('project')).option('-q, --quiet', text('quiet')).option('--record [bool]', text('record'), coerceFalse).option('-r, --reporter <reporter>', text('reporter')).option('-o, --reporter-options <reporter-options>', text('reporterOptions')).option('-s, --spec <spec>', text('spec')).option('-t, --tag <tag>', text('tag')).option('--dev', text('dev'), coerceFalse);
};
var addCypressOpenCommand = function addCypressOpenCommand(program) {
  return program.command('open').usage('[options]').description('Opens Cypress in the interactive GUI.').option('-b, --browser <browser-path>', text('browser')).option('--component', text('component')).option('-c, --config <config>', text('config')).option('-C, --config-file <config-file>', text('configFile')).option('-d, --detached [bool]', text('detached'), coerceFalse).option('--e2e', text('e2e')).option('-e, --env <env>', text('env')).option('--global', text('global')).option('-p, --port <port>', text('port')).option('-P, --project <project-path>', text('project')).option('--dev', text('dev'), coerceFalse);
};
var maybeAddInspectFlags = function maybeAddInspectFlags(program) {
  if (process.argv.includes('--dev')) {
    return program.option('--inspect', 'Node option').option('--inspect-brk', 'Node option');
  }
  return program;
};

/**
 * Casts known command line options for "cypress run" to their intended type.
 * For example if the user passes "--port 5005" the ".port" property should be
 * a number 5005 and not a string "5005".
 *
 * Returns a clone of the original object.
 */
var castCypressOptions = function castCypressOptions(opts) {
  // only properties that have type "string | false" in our TS definition
  // require special handling, because CLI parsing takes care of purely
  // boolean arguments
  var castOpts = _objectSpread({}, opts);
  if (_.has(opts, 'port')) {
    castOpts.port = coerceAnyStringToInt(opts.port);
  }
  return castOpts;
};
module.exports = {
  /**
   * Parses `cypress run` command line option array into an object
   * with options that you can feed into a `cypress.run()` module API call.
   * @example
   *  const options = parseRunCommand(['cypress', 'run', '--browser', 'chrome'])
   *  // options is {browser: 'chrome'}
   */
  parseRunCommand: function parseRunCommand(args) {
    return new Promise(function (resolve, reject) {
      if (!Array.isArray(args)) {
        return reject(new Error('Expected array of arguments'));
      }

      // make a copy of the input arguments array
      // and add placeholders where "node ..." would usually be
      // also remove "cypress" keyword at the start if present
      var cliArgs = args[0] === 'cypress' ? _toConsumableArray(args.slice(1)) : _toConsumableArray(args);
      cliArgs.unshift(null, null);
      debug('creating program parser');
      var program = createProgram();
      maybeAddInspectFlags(addCypressRunCommand(program)).action(function () {
        for (var _len = arguments.length, fnArgs = new Array(_len), _key = 0; _key < _len; _key++) {
          fnArgs[_key] = arguments[_key];
        }
        debug('parsed Cypress run %o', fnArgs);
        var options = parseVariableOpts(fnArgs, cliArgs);
        debug('parsed options %o', options);
        var casted = castCypressOptions(options);
        debug('casted options %o', casted);
        resolve(casted);
      });
      debug('parsing args: %o', cliArgs);
      program.parse(cliArgs);
    });
  },
  /**
   * Parses `cypress open` command line option array into an object
   * with options that you can feed into cy.openModeSystemTest test calls
   * @example
   *  const options = parseOpenCommand(['cypress', 'open', '--browser', 'chrome'])
   *  // options is {browser: 'chrome'}
   */
  parseOpenCommand: function parseOpenCommand(args) {
    return new Promise(function (resolve, reject) {
      if (!Array.isArray(args)) {
        return reject(new Error('Expected array of arguments'));
      }

      // make a copy of the input arguments array
      // and add placeholders where "node ..." would usually be
      // also remove "cypress" keyword at the start if present
      var cliArgs = args[0] === 'cypress' ? _toConsumableArray(args.slice(1)) : _toConsumableArray(args);
      cliArgs.unshift(null, null);
      debug('creating program parser');
      var program = createProgram();
      maybeAddInspectFlags(addCypressOpenCommand(program)).action(function () {
        for (var _len2 = arguments.length, fnArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          fnArgs[_key2] = arguments[_key2];
        }
        debug('parsed Cypress open %o', fnArgs);
        var options = parseVariableOpts(fnArgs, cliArgs);
        debug('parsed options %o', options);
        var casted = castCypressOptions(options);
        debug('casted options %o', casted);
        resolve(casted);
      });
      debug('parsing args: %o', cliArgs);
      program.parse(cliArgs);
    });
  },
  /**
   * Parses the command line and kicks off Cypress process.
   */
  init: function init(args) {
    if (!args) {
      args = process.argv;
    }
    var _process$env = process.env,
      CYPRESS_INTERNAL_ENV = _process$env.CYPRESS_INTERNAL_ENV,
      CYPRESS_DOWNLOAD_USE_CA = _process$env.CYPRESS_DOWNLOAD_USE_CA;
    if (process.env.CYPRESS_DOWNLOAD_USE_CA) {
      var msg = "\n        ".concat(logSymbols.warning, " Warning: It looks like you're setting CYPRESS_DOWNLOAD_USE_CA=").concat(CYPRESS_DOWNLOAD_USE_CA, "\n\n        The environment variable \"CYPRESS_DOWNLOAD_USE_CA\" is no longer required to be set.\n        \n        You can safely unset this environment variable.\n      ");
      logger.log();
      logger.warn(stripIndent(msg));
      logger.log();
    }
    if (!util.isValidCypressInternalEnvValue(CYPRESS_INTERNAL_ENV)) {
      debug('invalid CYPRESS_INTERNAL_ENV value', CYPRESS_INTERNAL_ENV);
      return errors.exitWithError(errors.errors.invalidCypressEnv)("CYPRESS_INTERNAL_ENV=".concat(CYPRESS_INTERNAL_ENV));
    }
    if (util.isNonProductionCypressInternalEnvValue(CYPRESS_INTERNAL_ENV)) {
      debug('non-production CYPRESS_INTERNAL_ENV value', CYPRESS_INTERNAL_ENV);
      var _msg = "\n        ".concat(logSymbols.warning, " Warning: It looks like you're passing CYPRESS_INTERNAL_ENV=").concat(CYPRESS_INTERNAL_ENV, "\n\n        The environment variable \"CYPRESS_INTERNAL_ENV\" is reserved and should only be used internally.\n\n        Unset the \"CYPRESS_INTERNAL_ENV\" environment variable and run Cypress again.\n      ");
      logger.log();
      logger.warn(stripIndent(_msg));
      logger.log();
    }
    var program = createProgram();
    program.command('help').description('Shows CLI help and exits').action(function () {
      program.help();
    });
    var handleVersion = function handleVersion(cmd) {
      return cmd.option('--component <package|binary|electron|node>', 'component to report version for').action(function (opts) {
        showVersions(util.parseOpts(opts));
      });
    };
    handleVersion(program.storeOptionsAsProperties().option('-v, --version', text('version')).command('version').description(text('version')));
    maybeAddInspectFlags(addCypressOpenCommand(program)).action(function (opts) {
      debug('opening Cypress');
      require('./exec/open').start(util.parseOpts(opts)).then(util.exit)["catch"](util.logErrorExit1);
    });
    maybeAddInspectFlags(addCypressRunCommand(program)).action(function () {
      for (var _len3 = arguments.length, fnArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        fnArgs[_key3] = arguments[_key3];
      }
      debug('running Cypress with args %o', fnArgs);
      require('./exec/run').start(parseVariableOpts(fnArgs, args)).then(util.exit)["catch"](util.logErrorExit1);
    });
    program.command('open-ct').usage('[options]').description('Opens Cypress component testing interactive mode. Deprecated: use "open --component"').option('-b, --browser <browser-path>', text('browser')).option('-c, --config <config>', text('config')).option('-C, --config-file <config-file>', text('configFile')).option('-d, --detached [bool]', text('detached'), coerceFalse).option('-e, --env <env>', text('env')).option('--global', text('global')).option('-p, --port <port>', text('port')).option('-P, --project <project-path>', text('project')).option('--dev', text('dev'), coerceFalse).action(function (opts) {
      debug('opening Cypress');
      var msg = "\n      ".concat(logSymbols.warning, " Warning: open-ct is deprecated and will be removed in a future release.\n\n      Use `cypress open --component` instead.\n      ");
      logger.warn();
      logger.warn(stripIndent(msg));
      logger.warn();
      require('./exec/open').start(_objectSpread(_objectSpread({}, util.parseOpts(opts)), {}, {
        testingType: 'component'
      })).then(util.exit)["catch"](util.logErrorExit1);
    });
    program.command('run-ct').usage('[options]').description('Runs all Cypress component testing suites. Deprecated: use "run --component"').option('-b, --browser <browser-name-or-path>', text('browser')).option('--ci-build-id <id>', text('ciBuildId')).option('-c, --config <config>', text('config')).option('-C, --config-file <config-file>', text('configFile')).option('-e, --env <env>', text('env')).option('--group <name>', text('group')).option('-k, --key <record-key>', text('key')).option('--headed', text('headed')).option('--headless', text('headless')).option('--no-exit', text('exit')).option('--parallel', text('parallel')).option('-p, --port <port>', text('port')).option('-P, --project <project-path>', text('project')).option('-q, --quiet', text('quiet')).option('--record [bool]', text('record'), coerceFalse).option('-r, --reporter <reporter>', text('reporter')).option('-o, --reporter-options <reporter-options>', text('reporterOptions')).option('-s, --spec <spec>', text('spec')).option('-t, --tag <tag>', text('tag')).option('--dev', text('dev'), coerceFalse).action(function (opts) {
      debug('running Cypress run-ct');
      var msg = "\n      ".concat(logSymbols.warning, " Warning: run-ct is deprecated and will be removed in a future release.\n      Use `cypress run --component` instead.\n      ");
      logger.warn();
      logger.warn(stripIndent(msg));
      logger.warn();
      require('./exec/run').start(_objectSpread(_objectSpread({}, util.parseOpts(opts)), {}, {
        testingType: 'component'
      })).then(util.exit)["catch"](util.logErrorExit1);
    });
    program.command('install').usage('[options]').description('Installs the Cypress executable matching this package\'s version').option('-f, --force', text('forceInstall')).action(function (opts) {
      require('./tasks/install').start(util.parseOpts(opts))["catch"](util.logErrorExit1);
    });
    program.command('verify').usage('[options]').description('Verifies that Cypress is installed correctly and executable').option('--dev', text('dev'), coerceFalse).action(function (opts) {
      var defaultOpts = {
        force: true,
        welcomeMessage: false
      };
      var parsedOpts = util.parseOpts(opts);
      var options = _.extend(parsedOpts, defaultOpts);
      require('./tasks/verify').start(options)["catch"](util.logErrorExit1);
    });
    program.command('cache').usage('[command]').description('Manages the Cypress binary cache').option('list', text('cacheList')).option('path', text('cachePath')).option('clear', text('cacheClear')).option('prune', text('cachePrune')).option('--size', text('cacheSize')).action(function (opts, args) {
      if (!args || !args.length) {
        this.outputHelp();
        util.exit(1);
      }
      var _args = _slicedToArray(args, 1),
        command = _args[0];
      if (!_.includes(['list', 'path', 'clear', 'prune'], command)) {
        unknownOption.call(this, "cache ".concat(command), 'command');
      }
      if (command === 'list') {
        debug('cache command %o', {
          command: command,
          size: opts.size
        });
        return cache.list(opts.size)["catch"]({
          code: 'ENOENT'
        }, function () {
          logger.always('No cached binary versions were found.');
          process.exit(0);
        })["catch"](function (e) {
          debug('cache list command failed with "%s"', e.message);
          util.logErrorExit1(e);
        });
      }
      cache[command]();
    });
    program.command('info').usage('[command]').description('Prints Cypress and system information').option('--dev', text('dev'), coerceFalse).action(function (opts) {
      require('./exec/info').start(opts).then(util.exit)["catch"](util.logErrorExit1);
    });
    debug('cli starts with arguments %j', args);
    util.printNodeOptions();

    // if there are no arguments
    if (args.length <= 2) {
      debug('printing help');
      program.help();
      // exits
    }

    var firstCommand = args[2];
    if (!_.includes(knownCommands, firstCommand)) {
      debug('unknown command %s', firstCommand);
      logger.error('Unknown command', "\"".concat(firstCommand, "\""));
      program.outputHelp();
      return util.exit(1);
    }
    if (includesVersion(args)) {
      // commander 2.11.0 changes behavior
      // and now does not understand top level options
      // .option('-v, --version').command('version')
      // so we have to manually catch '-v, --version'
      handleVersion(program);
    }
    debug('program parsing arguments');
    return program.parse(args);
  }
};

// @ts-ignore
if (!module.parent) {
  logger.error('This CLI module should be required from another Node module');
  logger.error('and not executed directly');
  process.exit(-1);
}