'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var toString = Object.prototype.toString;
var colors = require('ansi-colors');
var called = false;
var fns = [];
var complements = {
  'yellow': 'blue',
  'cyan': 'red',
  'green': 'magenta',
  'black': 'white',
  'blue': 'yellow',
  'red': 'cyan',
  'magenta': 'green',
  'white': 'black'
};
exports.longest = function (arr, prop) {
  return arr.reduce(function (a, v) {
    return Math.max(a, prop ? v[prop].length : v.length);
  }, 0);
};
exports.hasColor = function (str) {
  return !!str && colors.hasColor(str);
};
var isObject = exports.isObject = function (val) {
  return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
};
exports.nativeType = function (val) {
  return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, '');
};
exports.isAsyncFn = function (val) {
  return exports.nativeType(val) === 'asyncfunction';
};
exports.isPrimitive = function (val) {
  return val != null && _typeof(val) !== 'object' && typeof val !== 'function';
};
exports.resolve = function (context, value) {
  if (typeof value === 'function') {
    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }
    return value.call.apply(value, [context].concat(rest));
  }
  return value;
};
exports.scrollDown = function () {
  var choices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return [].concat(_toConsumableArray(choices.slice(1)), [choices[0]]);
};
exports.scrollUp = function () {
  var choices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return [choices.pop()].concat(_toConsumableArray(choices));
};
exports.reorder = function () {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var res = arr.slice();
  res.sort(function (a, b) {
    if (a.index > b.index) return 1;
    if (a.index < b.index) return -1;
    return 0;
  });
  return res;
};
exports.swap = function (arr, index, pos) {
  var len = arr.length;
  var idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
  var choice = arr[index];
  arr[index] = arr[idx];
  arr[idx] = choice;
};
exports.width = function (stream) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;
  var columns = stream && stream.columns ? stream.columns : fallback;
  if (stream && typeof stream.getWindowSize === 'function') {
    columns = stream.getWindowSize()[0];
  }
  if (process.platform === 'win32') {
    return columns - 1;
  }
  return columns;
};
exports.height = function (stream) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
  var rows = stream && stream.rows ? stream.rows : fallback;
  if (stream && typeof stream.getWindowSize === 'function') {
    rows = stream.getWindowSize()[1];
  }
  return rows;
};
exports.wordWrap = function (str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!str) return str;
  if (typeof options === 'number') {
    options = {
      width: options
    };
  }
  var _options = options,
    _options$indent = _options.indent,
    indent = _options$indent === void 0 ? '' : _options$indent,
    _options$newline = _options.newline,
    newline = _options$newline === void 0 ? '\n' + indent : _options$newline,
    _options$width = _options.width,
    width = _options$width === void 0 ? 80 : _options$width;
  var spaces = (newline + indent).match(/[^\S\n]/g) || [];
  width -= spaces.length;
  var source = ".{1,".concat(width, "}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)");
  var output = str.trim();
  var regex = new RegExp(source, 'g');
  var lines = output.match(regex) || [];
  lines = lines.map(function (line) {
    return line.replace(/\n$/, '');
  });
  if (options.padEnd) lines = lines.map(function (line) {
    return line.padEnd(width, ' ');
  });
  if (options.padStart) lines = lines.map(function (line) {
    return line.padStart(width, ' ');
  });
  return indent + lines.join(newline);
};
exports.unmute = function (color) {
  var name = color.stack.find(function (n) {
    return colors.keys.color.includes(n);
  });
  if (name) {
    return colors[name];
  }
  var bg = color.stack.find(function (n) {
    return n.slice(2) === 'bg';
  });
  if (bg) {
    return colors[name.slice(2)];
  }
  return function (str) {
    return str;
  };
};
exports.pascal = function (str) {
  return str ? str[0].toUpperCase() + str.slice(1) : '';
};
exports.inverse = function (color) {
  if (!color || !color.stack) return color;
  var name = color.stack.find(function (n) {
    return colors.keys.color.includes(n);
  });
  if (name) {
    var col = colors['bg' + exports.pascal(name)];
    return col ? col.black : color;
  }
  var bg = color.stack.find(function (n) {
    return n.slice(0, 2) === 'bg';
  });
  if (bg) {
    return colors[bg.slice(2).toLowerCase()] || color;
  }
  return colors.none;
};
exports.complement = function (color) {
  if (!color || !color.stack) return color;
  var name = color.stack.find(function (n) {
    return colors.keys.color.includes(n);
  });
  var bg = color.stack.find(function (n) {
    return n.slice(0, 2) === 'bg';
  });
  if (name && !bg) {
    return colors[complements[name] || name];
  }
  if (bg) {
    var lower = bg.slice(2).toLowerCase();
    var comp = complements[lower];
    if (!comp) return color;
    return colors['bg' + exports.pascal(comp)] || color;
  }
  return colors.none;
};
exports.meridiem = function (date) {
  var hours = date.getHours();
  var minutes = date.getMinutes();
  var ampm = hours >= 12 ? 'pm' : 'am';
  hours = hours % 12;
  var hrs = hours === 0 ? 12 : hours;
  var min = minutes < 10 ? '0' + minutes : minutes;
  return hrs + ':' + min + ' ' + ampm;
};

/**
 * Set a value on the given object.
 * @param {Object} obj
 * @param {String} prop
 * @param {any} value
 */

exports.set = function () {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var val = arguments.length > 2 ? arguments[2] : undefined;
  return prop.split('.').reduce(function (acc, k, i, arr) {
    var value = arr.length - 1 > i ? acc[k] || {} : val;
    if (!exports.isObject(value) && i < arr.length - 1) value = {};
    return acc[k] = value;
  }, obj);
};

/**
 * Get a value from the given object.
 * @param {Object} obj
 * @param {String} prop
 */

exports.get = function () {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var fallback = arguments.length > 2 ? arguments[2] : undefined;
  var value = obj[prop] == null ? prop.split('.').reduce(function (acc, k) {
    return acc && acc[k];
  }, obj) : obj[prop];
  return value == null ? fallback : value;
};
exports.mixin = function (target, b) {
  if (!isObject(target)) return b;
  if (!isObject(b)) return target;
  for (var _i = 0, _Object$keys = Object.keys(b); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var desc = Object.getOwnPropertyDescriptor(b, key);
    if (desc.hasOwnProperty('value')) {
      if (target.hasOwnProperty(key) && isObject(desc.value)) {
        var existing = Object.getOwnPropertyDescriptor(target, key);
        if (isObject(existing.value)) {
          target[key] = exports.merge({}, target[key], b[key]);
        } else {
          Reflect.defineProperty(target, key, desc);
        }
      } else {
        Reflect.defineProperty(target, key, desc);
      }
    } else {
      Reflect.defineProperty(target, key, desc);
    }
  }
  return target;
};
exports.merge = function () {
  var target = {};
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  for (var _i2 = 0, _args = args; _i2 < _args.length; _i2++) {
    var ele = _args[_i2];
    exports.mixin(target, ele);
  }
  return target;
};
exports.mixinEmitter = function (obj, emitter) {
  var proto = emitter.constructor.prototype;
  for (var _i3 = 0, _Object$keys2 = Object.keys(proto); _i3 < _Object$keys2.length; _i3++) {
    var key = _Object$keys2[_i3];
    var val = proto[key];
    if (typeof val === 'function') {
      exports.define(obj, key, val.bind(emitter));
    } else {
      exports.define(obj, key, val);
    }
  }
};
exports.onExit = function (callback) {
  var onExit = function onExit(quit, code) {
    if (called) return;
    called = true;
    fns.forEach(function (fn) {
      return fn();
    });
    if (quit === true) {
      process.exit(128 + code);
    }
  };
  if (fns.length === 0) {
    process.once('SIGTERM', onExit.bind(null, true, 15));
    process.once('SIGINT', onExit.bind(null, true, 2));
    process.once('exit', onExit);
  }
  fns.push(callback);
};
exports.define = function (obj, key, value) {
  Reflect.defineProperty(obj, key, {
    value: value
  });
};
exports.defineExport = function (obj, key, fn) {
  var custom;
  Reflect.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    set: function set(val) {
      custom = val;
    },
    get: function get() {
      return custom ? custom() : fn();
    }
  });
};