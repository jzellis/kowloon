"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._compileUnsafe = exports._compileToken = void 0;
Object.defineProperty(exports, "aliases", {
  enumerable: true,
  get: function get() {
    return _index.aliases;
  }
});
exports["default"] = exports.compile = void 0;
Object.defineProperty(exports, "filters", {
  enumerable: true,
  get: function get() {
    return _index.filters;
  }
});
exports.is = is;
exports.prepareContext = prepareContext;
Object.defineProperty(exports, "pseudos", {
  enumerable: true,
  get: function get() {
    return _index.pseudos;
  }
});
exports.selectOne = exports.selectAll = void 0;
var DomUtils = _interopRequireWildcard(require("domutils"));
var _boolbase = _interopRequireDefault(require("boolbase"));
var _compile = require("./compile.js");
var _subselects = require("./pseudo-selectors/subselects.js");
var _index = require("./pseudo-selectors/index.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var defaultEquals = function defaultEquals(a, b) {
  return a === b;
};
var defaultOptions = {
  adapter: DomUtils,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a, _b, _c, _d;
  /*
   * We force one format of options to the other one.
   */
  // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
  var opts = options !== null && options !== void 0 ? options : defaultOptions;
  // @ts-expect-error Same as above.
  (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
  // @ts-expect-error `equals` does not exist on `Options`
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    var opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
/**
 * Compiles the query, returns a function.
 */
var compile = wrapCompile(_compile.compile);
exports.compile = compile;
var _compileUnsafe = wrapCompile(_compile.compileUnsafe);
exports._compileUnsafe = _compileUnsafe;
var _compileToken = wrapCompile(_compile.compileToken);
exports._compileToken = _compileToken;
function getSelectorFunc(searchFunc) {
  return function select(query, elements, options) {
    var opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = (0, _compile.compileUnsafe)(query, opts, elements);
    }
    var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems, adapter) {
  var shouldTestNextSiblings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  /*
   * Add siblings if the query requires them.
   * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
   */
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter);
  }
  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
}
function appendNextSiblings(elem, adapter) {
  // Order matters because jQuery seems to check the children before the siblings
  var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  var elemsLength = elems.length;
  for (var i = 0; i < elemsLength; i++) {
    var nextSiblings = (0, _subselects.getNextSiblings)(elems[i], adapter);
    elems.push.apply(elems, _toConsumableArray(nextSiblings));
  }
  return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
var selectAll = getSelectorFunc(function (query, elems, options) {
  return query === _boolbase["default"].falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectAll = selectAll;
var selectOne = getSelectorFunc(function (query, elems, options) {
  return query === _boolbase["default"].falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
exports.selectOne = selectOne;
function is(elem, query, options) {
  var opts = convertOptionFormats(options);
  return (typeof query === "function" ? query : (0, _compile.compile)(query, opts))(elem);
}
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
var _default = selectAll; // Export filters, pseudos and aliases to allow users to supply their own.
/** @deprecated Use the `pseudos` option instead. */
exports["default"] = _default;