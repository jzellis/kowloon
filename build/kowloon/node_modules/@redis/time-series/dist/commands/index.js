"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pushLatestArgument = exports.transformMRangeWithLabelsReply = exports.transformMRangeReply = exports.transformRangeReply = exports.pushMRangeWithLabelsArguments = exports.pushWithLabelsArgument = exports.pushMRangeArguments = exports.pushFilterArgument = exports.pushMRangeGroupByArguments = exports.pushRangeArguments = exports.TimeSeriesBucketTimestamp = exports.transformSampleReply = exports.transformIncrDecrArguments = exports.pushLabelsArgument = exports.transformLablesReply = exports.pushDuplicatePolicy = exports.pushChunkSizeArgument = exports.pushEncodingArgument = exports.TimeSeriesEncoding = exports.pushRetentionArgument = exports.transformTimestampArgument = exports.TimeSeriesReducers = exports.TimeSeriesDuplicatePolicies = exports.TimeSeriesAggregationType = void 0;
var ADD = require("./ADD");
var ALTER = require("./ALTER");
var CREATE = require("./CREATE");
var CREATERULE = require("./CREATERULE");
var DECRBY = require("./DECRBY");
var DEL = require("./DEL");
var DELETERULE = require("./DELETERULE");
var GET = require("./GET");
var INCRBY = require("./INCRBY");
var INFO_DEBUG = require("./INFO_DEBUG");
var INFO = require("./INFO");
var MADD = require("./MADD");
var MGET = require("./MGET");
var MGET_WITHLABELS = require("./MGET_WITHLABELS");
var QUERYINDEX = require("./QUERYINDEX");
var RANGE = require("./RANGE");
var REVRANGE = require("./REVRANGE");
var MRANGE = require("./MRANGE");
var MRANGE_WITHLABELS = require("./MRANGE_WITHLABELS");
var MREVRANGE = require("./MREVRANGE");
var MREVRANGE_WITHLABELS = require("./MREVRANGE_WITHLABELS");
var generic_transformers_1 = require("@redis/client/dist/lib/commands/generic-transformers");
exports["default"] = {
  ADD: ADD,
  add: ADD,
  ALTER: ALTER,
  alter: ALTER,
  CREATE: CREATE,
  create: CREATE,
  CREATERULE: CREATERULE,
  createRule: CREATERULE,
  DECRBY: DECRBY,
  decrBy: DECRBY,
  DEL: DEL,
  del: DEL,
  DELETERULE: DELETERULE,
  deleteRule: DELETERULE,
  GET: GET,
  get: GET,
  INCRBY: INCRBY,
  incrBy: INCRBY,
  INFO_DEBUG: INFO_DEBUG,
  infoDebug: INFO_DEBUG,
  INFO: INFO,
  info: INFO,
  MADD: MADD,
  mAdd: MADD,
  MGET: MGET,
  mGet: MGET,
  MGET_WITHLABELS: MGET_WITHLABELS,
  mGetWithLabels: MGET_WITHLABELS,
  QUERYINDEX: QUERYINDEX,
  queryIndex: QUERYINDEX,
  RANGE: RANGE,
  range: RANGE,
  REVRANGE: REVRANGE,
  revRange: REVRANGE,
  MRANGE: MRANGE,
  mRange: MRANGE,
  MRANGE_WITHLABELS: MRANGE_WITHLABELS,
  mRangeWithLabels: MRANGE_WITHLABELS,
  MREVRANGE: MREVRANGE,
  mRevRange: MREVRANGE,
  MREVRANGE_WITHLABELS: MREVRANGE_WITHLABELS,
  mRevRangeWithLabels: MREVRANGE_WITHLABELS
};
var TimeSeriesAggregationType;
(function (TimeSeriesAggregationType) {
  TimeSeriesAggregationType["AVG"] = "AVG";
  // @deprecated
  TimeSeriesAggregationType["AVERAGE"] = "AVG";
  TimeSeriesAggregationType["FIRST"] = "FIRST";
  TimeSeriesAggregationType["LAST"] = "LAST";
  TimeSeriesAggregationType["MIN"] = "MIN";
  // @deprecated
  TimeSeriesAggregationType["MINIMUM"] = "MIN";
  TimeSeriesAggregationType["MAX"] = "MAX";
  // @deprecated
  TimeSeriesAggregationType["MAXIMUM"] = "MAX";
  TimeSeriesAggregationType["SUM"] = "SUM";
  TimeSeriesAggregationType["RANGE"] = "RANGE";
  TimeSeriesAggregationType["COUNT"] = "COUNT";
  TimeSeriesAggregationType["STD_P"] = "STD.P";
  TimeSeriesAggregationType["STD_S"] = "STD.S";
  TimeSeriesAggregationType["VAR_P"] = "VAR.P";
  TimeSeriesAggregationType["VAR_S"] = "VAR.S";
  TimeSeriesAggregationType["TWA"] = "TWA";
})(TimeSeriesAggregationType = exports.TimeSeriesAggregationType || (exports.TimeSeriesAggregationType = {}));
var TimeSeriesDuplicatePolicies;
(function (TimeSeriesDuplicatePolicies) {
  TimeSeriesDuplicatePolicies["BLOCK"] = "BLOCK";
  TimeSeriesDuplicatePolicies["FIRST"] = "FIRST";
  TimeSeriesDuplicatePolicies["LAST"] = "LAST";
  TimeSeriesDuplicatePolicies["MIN"] = "MIN";
  TimeSeriesDuplicatePolicies["MAX"] = "MAX";
  TimeSeriesDuplicatePolicies["SUM"] = "SUM";
})(TimeSeriesDuplicatePolicies = exports.TimeSeriesDuplicatePolicies || (exports.TimeSeriesDuplicatePolicies = {}));
var TimeSeriesReducers;
(function (TimeSeriesReducers) {
  TimeSeriesReducers["AVG"] = "AVG";
  TimeSeriesReducers["SUM"] = "SUM";
  TimeSeriesReducers["MIN"] = "MIN";
  // @deprecated
  TimeSeriesReducers["MINIMUM"] = "MIN";
  TimeSeriesReducers["MAX"] = "MAX";
  // @deprecated
  TimeSeriesReducers["MAXIMUM"] = "MAX";
  TimeSeriesReducers["RANGE"] = "range";
  TimeSeriesReducers["COUNT"] = "COUNT";
  TimeSeriesReducers["STD_P"] = "STD.P";
  TimeSeriesReducers["STD_S"] = "STD.S";
  TimeSeriesReducers["VAR_P"] = "VAR.P";
  TimeSeriesReducers["VAR_S"] = "VAR.S";
})(TimeSeriesReducers = exports.TimeSeriesReducers || (exports.TimeSeriesReducers = {}));
function transformTimestampArgument(timestamp) {
  if (typeof timestamp === 'string') return timestamp;
  return (typeof timestamp === 'number' ? timestamp : timestamp.getTime()).toString();
}
exports.transformTimestampArgument = transformTimestampArgument;
function pushRetentionArgument(args, retention) {
  if (retention) {
    args.push('RETENTION', retention.toString());
  }
  return args;
}
exports.pushRetentionArgument = pushRetentionArgument;
var TimeSeriesEncoding;
(function (TimeSeriesEncoding) {
  TimeSeriesEncoding["COMPRESSED"] = "COMPRESSED";
  TimeSeriesEncoding["UNCOMPRESSED"] = "UNCOMPRESSED";
})(TimeSeriesEncoding = exports.TimeSeriesEncoding || (exports.TimeSeriesEncoding = {}));
function pushEncodingArgument(args, encoding) {
  if (encoding) {
    args.push('ENCODING', encoding);
  }
  return args;
}
exports.pushEncodingArgument = pushEncodingArgument;
function pushChunkSizeArgument(args, chunkSize) {
  if (chunkSize) {
    args.push('CHUNK_SIZE', chunkSize.toString());
  }
  return args;
}
exports.pushChunkSizeArgument = pushChunkSizeArgument;
function pushDuplicatePolicy(args, duplicatePolicy) {
  if (duplicatePolicy) {
    args.push('DUPLICATE_POLICY', duplicatePolicy);
  }
  return args;
}
exports.pushDuplicatePolicy = pushDuplicatePolicy;
function transformLablesReply(reply) {
  var labels = {};
  var _iterator = _createForOfIteratorHelper(reply),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        value = _step$value[1];
      labels[key] = value;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return labels;
}
exports.transformLablesReply = transformLablesReply;
function pushLabelsArgument(args, labels) {
  if (labels) {
    args.push('LABELS');
    for (var _i2 = 0, _Object$entries = Object.entries(labels); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        label = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
      args.push(label, value);
    }
  }
  return args;
}
exports.pushLabelsArgument = pushLabelsArgument;
function transformIncrDecrArguments(command, key, value, options) {
  var args = [command, key, value.toString()];
  if ((options === null || options === void 0 ? void 0 : options.TIMESTAMP) !== undefined && (options === null || options === void 0 ? void 0 : options.TIMESTAMP) !== null) {
    args.push('TIMESTAMP', transformTimestampArgument(options.TIMESTAMP));
  }
  pushRetentionArgument(args, options === null || options === void 0 ? void 0 : options.RETENTION);
  if (options !== null && options !== void 0 && options.UNCOMPRESSED) {
    args.push('UNCOMPRESSED');
  }
  pushChunkSizeArgument(args, options === null || options === void 0 ? void 0 : options.CHUNK_SIZE);
  pushLabelsArgument(args, options === null || options === void 0 ? void 0 : options.LABELS);
  return args;
}
exports.transformIncrDecrArguments = transformIncrDecrArguments;
function transformSampleReply(reply) {
  return {
    timestamp: reply[0],
    value: Number(reply[1])
  };
}
exports.transformSampleReply = transformSampleReply;
var TimeSeriesBucketTimestamp;
(function (TimeSeriesBucketTimestamp) {
  TimeSeriesBucketTimestamp["LOW"] = "-";
  TimeSeriesBucketTimestamp["HIGH"] = "+";
  TimeSeriesBucketTimestamp["MID"] = "~";
})(TimeSeriesBucketTimestamp = exports.TimeSeriesBucketTimestamp || (exports.TimeSeriesBucketTimestamp = {}));
function pushRangeArguments(args, fromTimestamp, toTimestamp, options) {
  args.push(transformTimestampArgument(fromTimestamp), transformTimestampArgument(toTimestamp));
  pushLatestArgument(args, options === null || options === void 0 ? void 0 : options.LATEST);
  if (options !== null && options !== void 0 && options.FILTER_BY_TS) {
    args.push('FILTER_BY_TS');
    var _iterator2 = _createForOfIteratorHelper(options.FILTER_BY_TS),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var ts = _step2.value;
        args.push(transformTimestampArgument(ts));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  if (options !== null && options !== void 0 && options.FILTER_BY_VALUE) {
    args.push('FILTER_BY_VALUE', options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
  }
  if (options !== null && options !== void 0 && options.COUNT) {
    args.push('COUNT', options.COUNT.toString());
  }
  if (options !== null && options !== void 0 && options.ALIGN) {
    args.push('ALIGN', transformTimestampArgument(options.ALIGN));
  }
  if (options !== null && options !== void 0 && options.AGGREGATION) {
    args.push('AGGREGATION', options.AGGREGATION.type, transformTimestampArgument(options.AGGREGATION.timeBucket));
    if (options.AGGREGATION.BUCKETTIMESTAMP) {
      args.push('BUCKETTIMESTAMP', options.AGGREGATION.BUCKETTIMESTAMP);
    }
    if (options.AGGREGATION.EMPTY) {
      args.push('EMPTY');
    }
  }
  return args;
}
exports.pushRangeArguments = pushRangeArguments;
function pushMRangeGroupByArguments(args, groupBy) {
  if (groupBy) {
    args.push('GROUPBY', groupBy.label, 'REDUCE', groupBy.reducer);
  }
  return args;
}
exports.pushMRangeGroupByArguments = pushMRangeGroupByArguments;
function pushFilterArgument(args, filter) {
  args.push('FILTER');
  return (0, generic_transformers_1.pushVerdictArguments)(args, filter);
}
exports.pushFilterArgument = pushFilterArgument;
function pushMRangeArguments(args, fromTimestamp, toTimestamp, filter, options) {
  args = pushRangeArguments(args, fromTimestamp, toTimestamp, options);
  args = pushFilterArgument(args, filter);
  return pushMRangeGroupByArguments(args, options === null || options === void 0 ? void 0 : options.GROUPBY);
}
exports.pushMRangeArguments = pushMRangeArguments;
function pushWithLabelsArgument(args, selectedLabels) {
  if (!selectedLabels) {
    args.push('WITHLABELS');
  } else {
    args.push('SELECTED_LABELS');
    args = (0, generic_transformers_1.pushVerdictArguments)(args, selectedLabels);
  }
  return args;
}
exports.pushWithLabelsArgument = pushWithLabelsArgument;
function pushMRangeWithLabelsArguments(args, fromTimestamp, toTimestamp, filter, options) {
  args = pushRangeArguments(args, fromTimestamp, toTimestamp, options);
  args = pushWithLabelsArgument(args, options === null || options === void 0 ? void 0 : options.SELECTED_LABELS);
  args = pushFilterArgument(args, filter);
  return pushMRangeGroupByArguments(args, options === null || options === void 0 ? void 0 : options.GROUPBY);
}
exports.pushMRangeWithLabelsArguments = pushMRangeWithLabelsArguments;
function transformRangeReply(reply) {
  return reply.map(transformSampleReply);
}
exports.transformRangeReply = transformRangeReply;
function transformMRangeReply(reply) {
  var args = [];
  var _iterator3 = _createForOfIteratorHelper(reply),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 3),
        key = _step3$value[0],
        _ = _step3$value[1],
        sample = _step3$value[2];
      args.push({
        key: key,
        samples: sample.map(transformSampleReply)
      });
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return args;
}
exports.transformMRangeReply = transformMRangeReply;
function transformMRangeWithLabelsReply(reply) {
  var args = [];
  var _iterator4 = _createForOfIteratorHelper(reply),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 3),
        key = _step4$value[0],
        labels = _step4$value[1],
        samples = _step4$value[2];
      args.push({
        key: key,
        labels: transformLablesReply(labels),
        samples: samples.map(transformSampleReply)
      });
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return args;
}
exports.transformMRangeWithLabelsReply = transformMRangeWithLabelsReply;
function pushLatestArgument(args, latest) {
  if (latest) {
    args.push('LATEST');
  }
  return args;
}
exports.pushLatestArgument = pushLatestArgument;